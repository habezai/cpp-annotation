<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>index</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<ul>
<li>
Table of Contents | <a href="index.html">目录</a>

<li>
Chapter 1: Overview Of The Chapters | <a href="第1章 章节概述.html">第1章 章节概述</a>

<li>
Chapter 2: Introduction | <a href="第2章 引言.html">第2章 引言</a>

<ul>
<li>
2.1: What's new in the C++ Annotations | <a href="C++注释中的新增功能.html">C++注释中的新增功能</a>

<li>
2.2: C++'s history | <a href="C++的历史.html">C++的历史</a>

<ul>
<li>
2.2.1: History of the C++ Annotations | <a href="C++注释的历史.html">C++注释的历史</a>

<li>
2.2.2: Compiling a C program using a C++ compiler | <a href="使用C++编译器编译 C 程序.html">使用C++编译器编译 C 程序</a>

<li>
2.2.3: Compiling a C++ program | <a href="编译C++程序.html">编译C++程序</a>

<ul>
<li>
2.2.3.1: C++ under MS-Windows | <a href="在 MS-Windows 下C++.html">在 MS-Windows 下C++</a>

<li>
2.2.3.2: Compiling a C++ source text | <a href="编译C++源文本.html">编译C++源文本</a>

</ul>
</ul>
<li>
2.3: C++: advantages and claims | <a href="C++：优势和主张.html">C++：优势和主张</a>

<li>
2.4: What is Object-Oriented Programming? | <a href="什么是面向对象编程？.html">什么是面向对象编程？</a>

<li>
2.5: Differences between C and C++ | <a href="第2章 引言.html#2.5: C 和 C++ 之间的差异">C 和 C++ 之间的差异</a>

<ul>
<li>
2.5.1: The function <code>main</code> | <a href="函数main.html">函数main</a>

<li>
2.5.2: End-of-line comment | <a href="行尾注释.html">行尾注释</a>

<li>
2.5.3: Strict type checking | <a href="严格的类型检查.html">严格的类型检查</a>

<li>
2.5.4: Function Overloading | <a href="函数重载.html">函数重载</a>

<li>
2.5.5: Default function arguments | <a href="默认函数参数.html">默认函数参数</a>

<li>
2.5.6: NULL-pointers vs. 0-pointers and nullptr | <a href="空指针与 0 指针和空指针.html">空指针与 0 指针和空指针</a>

<li>
2.5.7: The <code>void</code> parameter list | <a href="参数列表void.html">参数列表void</a>

<li>
2.5.8: The <code>#define __cplusplus</code> | <a href="index.html#define __cplusplus">#define __cplusplus</a>

<li>
2.5.9: Using standard C functions | <a href="使用标准 C 函数.html">使用标准 C 函数</a>

<li>
2.5.10: Header files for both C and C++ | <a href="C 和 C++ 的头文件.html">C 和 C++ 的头文件</a>

<li>
2.5.11: Defining local variables | <a href="定义局部变量.html">定义局部变量</a>

<li>
2.5.12: The keyword <code>typedef</code> | <a href="关键字typedef.html">关键字typedef</a>

<li>
2.5.13: Functions as part of a struct | <a href="作为结构的一部分的函数.html">作为结构的一部分的函数</a>

<li>
2.5.14: Evaluation order of operands | <a href="操作数的求值顺序.html">操作数的求值顺序</a>

</ul>
</ul>
<li>
Chapter 3: A First Impression Of C++ | <a href="第3章 C++的第一印象.html">第3章 C++的第一印象</a>

<ul>
<li>
3.1: Notable differences with C | <a href="与 C 语言的显著差异.html">与 C 语言的显著差异</a>

<ul>
<li>
3.1.1: Using the keyword <code>const</code> | <a href="使用关键字const.html">使用关键字const</a>

<li>
3.1.2: Namespaces | <a href="命名空间.html">命名空间</a>

<li>
3.1.3: The scope resolution operator <code>::</code> | <a href="范围解析运算符 :: .html">范围解析运算符 ::</a>

<li>
3.1.4: <code>cout</code>, <code>cin</code>, and <code>cerr</code> | <a href="、 和coutcincerr.html">、 和coutcincerr</a>

</ul>
<li>
3.2: Functions as part of structs | <a href="作为结构体的一部分的函数.html">作为结构体的一部分的函数</a>

<ul>
<li>
3.2.1: Data hiding: public, private and class | <a href="数据隐藏：公共、私有和类.html">数据隐藏：公共、私有和类</a>

<li>
3.2.2: Structs in C vs. structs in C++ | <a href="C 语言中的结构与 C++ 中的结构.html">C 语言中的结构与 C++ 中的结构</a>

</ul>
<li>
3.3: Several additions to C's grammar | <a href="对 C 语法的几个补充.html">对 C 语法的几个补充</a>

<ul>
<li>
3.3.1: References | <a href="参考资料.html">参考资料</a>

<li>
3.3.2: Rvalue References | <a href="右值引用.html">右值引用</a>

<li>
3.3.3: Lvalues, rvalues and more | <a href="左值、右值等.html">左值、右值等</a>

<li>
3.3.4: Strongly typed enumerations | <a href="强类型枚举.html">强类型枚举</a>

<li>
3.3.5: Initializer lists | <a href="初始值设定项列表.html">初始值设定项列表</a>

<ul>
<li>
3.3.5.1: Designated initialization | <a href="指定初始化.html">指定初始化</a>

</ul>
<li>
3.3.6: Initializers for bit-fields | <a href="位字段的初始值设定项.html">位字段的初始值设定项</a>

<li>
3.3.7: Type inference using <code>auto</code> | <a href="使用类型推断auto.html">使用类型推断auto</a>

<ul>
<li>
3.3.7.1: Structured binding declarations | <a href="结构化绑定声明.html">结构化绑定声明</a>

</ul>
<li>
3.3.8: Defining types and <code>using</code> declarations | <a href="定义类型和声明using.html">定义类型和声明using</a>

<li>
3.3.9: Range-based for-loops | <a href="基于范围的 for 循环.html">基于范围的 for 循环</a>

<li>
3.3.10: Raw String Literals | <a href="原始字符串文本.html">原始字符串文本</a>

<li>
3.3.11: Binary constants | <a href="二进制常量.html">二进制常量</a>

<li>
3.3.12: Selection statements with initializers | <a href="带有初始值设定项的选择语句.html">带有初始值设定项的选择语句</a>

<li>
3.3.13: Attributes | <a href="属性.html">属性</a>

<li>
3.3.14: Three-way comparison (&lt;	&gt;) | <a href="三向比较 （&lt;	&gt;）.html">三向比较 （&lt;	&gt;）</a>

</ul>
<li>
3.4: New language-defined data types | <a href="新的语言定义数据类型.html">新的语言定义数据类型</a>

<ul>
<li>
3.4.1: The data type <code>bool</code> | <a href="数据类型bool.html">数据类型bool</a>

<li>
3.4.2: The data type <code>wchar_t</code> | <a href="数据类型wchar_t.html">数据类型wchar_t</a>

<li>
3.4.3: Unicode encoding | <a href="统一码编码.html">统一码编码</a>

<li>
3.4.4: The data type <code>long long int</code> | <a href="数据类型long long int.html">数据类型long long int</a>

<li>
3.4.5: The data type <code>size_t</code> | <a href="数据类型size_t.html">数据类型size_t</a>

<li>
3.4.6: std::byte | <a href="标准：：字节.html">标准：：字节</a>

<li>
3.4.7: Digit separators | <a href="数字分隔符.html">数字分隔符</a>

</ul>
<li>
3.5: A new syntax for casts | <a href="强制转换的新语法.html">强制转换的新语法</a>

<ul>
<li>
3.5.1: The <code>static_cast</code>-operator | <a href="运算符static_cast.html">运算符static_cast</a>

<li>
3.5.2: The <code>const_cast</code>-operator | <a href="运算符const_cast.html">运算符const_cast</a>

<li>
3.5.3: The <code>reinterpret_cast</code>-operator | <a href="运算符reinterpret_cast.html">运算符reinterpret_cast</a>

<li>
3.5.4: The <code>dynamic_cast</code>-operator | <a href="运算符dynamic_cast.html">运算符dynamic_cast</a>

<li>
3.5.5: Casting <code>shared_ptr</code> objects | <a href="投射对象shared_ptr.html">投射对象shared_ptr</a>

</ul>
<li>
3.6: Keywords and reserved names in C++ | <a href="C++中的关键字和保留名称.html">C++中的关键字和保留名称</a>

</ul>
<li>
Chapter 4: Namespaces | <a href="第4章 命名空间.html">第4章 命名空间</a>

<ul>
<li>
4.1: Namespaces | <a href="命名空间.html">命名空间</a>

<ul>
<li>
4.1.1: Defining namespaces | <a href="定义命名空间.html">定义命名空间</a>

<ul>
<li>
4.1.1.1: Declaring entities in namespaces | <a href="在命名空间中声明实体.html">在命名空间中声明实体</a>

<li>
4.1.1.2: A closed namespace | <a href="封闭的命名空间.html">封闭的命名空间</a>

</ul>
<li>
4.1.2: Referring to entities | <a href="引用实体.html">引用实体</a>

<ul>
<li>
4.1.2.1: The <code>using</code> directive | <a href="指令using.html">指令using</a>

<li>
4.1.2.2: <code>Koenig lookup</code> | <a href="Koenig lookup.html">Koenig lookup</a>

</ul>
<li>
4.1.3: The standard namespace | <a href="标准命名空间.html">标准命名空间</a>

<li>
4.1.4: Nesting namespaces and namespace aliasing | <a href="嵌套命名空间和命名空间别名.html">嵌套命名空间和命名空间别名</a>

<ul>
<li>
4.1.4.1: Defining entities outside of their namespaces | <a href="定义命名空间之外的实体.html">定义命名空间之外的实体</a>

</ul>
</ul>
<li>
4.2: The std::chrono namespace (handling time) | <a href="标准：：时间命名空间（处理时间）.html">标准：：时间命名空间（处理时间）</a>

<ul>
<li>
4.2.1: Time resolutions: std::ratio | <a href="时间分辨率：标准：：比率.html">时间分辨率：标准：：比率</a>

<li>
4.2.2: Amounts of time: std::chrono::duration | <a href="时间量：标准：：时间：:d.html">时间量：标准：：时间：:d</a>

<li>
4.2.3: Clocks measuring time | <a href="时钟测量时间.html">时钟测量时间</a>

<li>
4.2.4: Points in time: std::chrono::time_point | <a href="时间点：标准：：时间：：time_point.html">时间点：标准：：时间：：time_point</a>

</ul>
<li>
4.3: The std::filesystem namespace | <a href="标准：：文件系统命名空间.html">标准：：文件系统命名空间</a>

<ul>
<li>
4.3.1: the <code>__file_clock</code> type | <a href="类型__file_clock.html">类型__file_clock</a>

<li>
4.3.2: The class <code>error_code</code> | <a href="类error_code.html">类error_code</a>

<li>
4.3.3: Names of file system entries: path | <a href="文件系统条目的名称：路径.html">文件系统条目的名称：路径</a>

<ul>
<li>
4.3.3.1: Accessors, modifiers and operators | <a href="访问器、修饰符和运算符.html">访问器、修饰符和运算符</a>

<li>
4.3.3.2: Free functions | <a href="自由函数.html">自由函数</a>

</ul>
<li>
4.3.4: Handling directories: directory_entry | <a href="处理目录：directory_entry.html">处理目录：directory_entry</a>

<ul>
<li>
4.3.4.1: Visiting directory entries: (recursive_)directory_iterator | <a href="访问目录条目：（recursive_）directory_iterator.html">访问目录条目：（recursive_）directory_iterator</a>

</ul>
<li>
4.3.5: Types (file_type) and permissions (perms) of file system elements: file_status | <a href="文件系统元素的类型 （file_type） 和权限 （perms）： file_status.html">文件系统元素的类型 （file_type） 和权限 （perms）： file_status</a>

<ul>
<li>
4.3.5.1: Obtaining the status of file system entries | <a href="获取文件系统条目的状态.html">获取文件系统条目的状态</a>

</ul>
<li>
4.3.6: Information about the space of file systems: space_info | <a href="有关文件系统空间的信息：space_info.html">有关文件系统空间的信息：space_info</a>

<li>
4.3.7: File system exceptions: filesystem_error | <a href="文件系统异常：filesystem_error.html">文件系统异常：filesystem_error</a>

</ul>
</ul>
<li>
Chapter 5: The <code>string</code> Data Type | <a href="第5章 数据类型string.html">第5章 数据类型string</a>

<ul>
<li>
5.1: Operations on strings | <a href="对字符串的操作.html">对字符串的操作</a>

<li>
5.2: A std::string reference | <a href="标准：：字符串引用.html">标准：：字符串引用</a>

<ul>
<li>
5.2.1: Initializers | <a href="初始值设定项.html">初始值设定项</a>

<li>
5.2.2: Iterators | <a href="迭代器.html">迭代器</a>

<li>
5.2.3: Operators | <a href="运算符.html">运算符</a>

<li>
5.2.4: Member functions | <a href="成员函数.html">成员函数</a>

<li>
5.2.5: Conversion functions | <a href="转换函数.html">转换函数</a>

</ul>
<li>
5.3: std::string_view | <a href="标准：：string_view.html">标准：：string_view</a>

</ul>
<li>
Chapter 6: The IO-stream Library | <a href="第6章 IO 流库.html">第6章 IO 流库</a>

<ul>
<li>
6.1: Special header files | <a href="特殊头文件.html">特殊头文件</a>

<li>
6.2: The foundation: the class <code>ios_base</code> | <a href="基础：类ios_base.html">基础：类ios_base</a>

<li>
6.3: Interfacing <code>streambuf</code> objects: the class <code>ios</code> | <a href="接口对象：类streambufios.html">接口对象：类streambufios</a>

<ul>
<li>
6.3.1: Condition states | <a href="条件状态.html">条件状态</a>

<li>
6.3.2: Formatting output and input | <a href="格式化输出和输入.html">格式化输出和输入</a>

<ul>
<li>
6.3.2.1: Format modifying member functions | <a href="修改成员函数的格式.html">修改成员函数的格式</a>

<li>
6.3.2.2: Formatting flags | <a href="格式化标志.html">格式化标志</a>

</ul>
</ul>
<li>
6.4: Output | <a href="输出.html">输出</a>

<ul>
<li>
6.4.1: Basic output: the class <code>ostream</code> | <a href="基本输出：类ostream.html">基本输出：类ostream</a>

<ul>
<li>
6.4.1.1: Writing to <code>ostream</code> objects | <a href="写入对象ostream.html">写入对象ostream</a>

<li>
6.4.1.2: <code>ostream</code> positioning | <a href="定位ostream.html">定位ostream</a>

<li>
6.4.1.3: <code>ostream</code> flushing | <a href="冲洗ostream.html">冲洗ostream</a>

</ul>
<li>
6.4.2: Output to files: the class <code>ofstream</code> | <a href="输出到文件：类ofstream.html">输出到文件：类ofstream</a>

<ul>
<li>
6.4.2.1: Modes for opening stream objects | <a href="打开流对象的模式.html">打开流对象的模式</a>

</ul>
<li>
6.4.3: Output to memory: the class <code>ostringstream</code> | <a href="输出到内存：类ostringstream.html">输出到内存：类ostringstream</a>

<li>
6.4.4: The <code>put_time</code> manipulator | <a href="机械手put_time.html">机械手put_time</a>

</ul>
<li>
6.5: Input | <a href="输入.html">输入</a>

<ul>
<li>
6.5.1: Basic input: the class <code>istream</code> | <a href="基本输入：类istream.html">基本输入：类istream</a>

<ul>
<li>
6.5.1.1: Reading from <code>istream</code> objects | <a href="从对象读取istream.html">从对象读取istream</a>

<li>
6.5.1.2: <code>istream</code> positioning | <a href="定位istream.html">定位istream</a>

</ul>
<li>
6.5.2: Input from files: the class <code>ifstream</code> | <a href="来自文件的输入：类ifstream.html">来自文件的输入：类ifstream</a>

<li>
6.5.3: Input from memory: the class <code>istringstream</code> | <a href="来自内存的输入：类istringstream.html">来自内存的输入：类istringstream</a>

<li>
6.5.4: Copying streams | <a href="复制流.html">复制流</a>

<li>
6.5.5: Coupling streams | <a href="耦合流.html">耦合流</a>

</ul>
<li>
6.6: Advanced topics | <a href="高级主题.html">高级主题</a>

<ul>
<li>
6.6.1: Moving streams | <a href="移动流.html">移动流</a>

<li>
6.6.2: Redirecting streams | <a href="重定向流.html">重定向流</a>

<li>
6.6.3: Reading AND Writing streams | <a href="读取和写入流.html">读取和写入流</a>

</ul>
</ul>
<li>
Chapter 7: Classes | <a href="第7章 上课.html">第7章 上课</a>

<ul>
<li>
7.1: The constructor | <a href="构造函数.html">构造函数</a>

<ul>
<li>
7.1.1: A first application | <a href="第一个应用程序.html">第一个应用程序</a>

<li>
7.1.2: Constructors: with and without arguments | <a href="构造函数：带参数和不带参数.html">构造函数：带参数和不带参数</a>

<ul>
<li>
7.1.2.1: The order of construction | <a href="构造顺序.html">构造顺序</a>

</ul>
</ul>
<li>
7.2: Ambiguity resolution | <a href="歧义解决.html">歧义解决</a>

<ul>
<li>
7.2.1: Types <code>Data</code> vs. <code>Data()</code> | <a href="类型与DataData().html">类型与DataData()</a>

<li>
7.2.2: Superfluous parentheses | <a href="多余的括号.html">多余的括号</a>

<li>
7.2.3: Existing types | <a href="现有类型.html">现有类型</a>

</ul>
<li>
7.3: Objects inside objects: composition | <a href="对象内部的对象：构图.html">对象内部的对象：构图</a>

<ul>
<li>
7.3.1: Composition and (const) objects: (const) member initializers | <a href="组合和 （const） 对象：（const） 成员初始值设定项.html">组合和 （const） 对象：（const） 成员初始值设定项</a>

<li>
7.3.2: Composition and reference objects: reference member initializers | <a href="组合和引用对象：引用成员初始值设定项.html">组合和引用对象：引用成员初始值设定项</a>

</ul>
<li>
7.4: Data member initializers | <a href="数据成员初始值设定项.html">数据成员初始值设定项</a>

<ul>
<li>
7.4.1: Delegating constructors | <a href="委派构造函数.html">委派构造函数</a>

</ul>
<li>
7.5: Uniform initialization | <a href="统一初始化.html">统一初始化</a>

<li>
7.6: Defaulted and deleted class members | <a href="默认和删除的类成员.html">默认和删除的类成员</a>

<li>
7.7: Const member functions and const objects | <a href="常量成员函数和常量对象.html">常量成员函数和常量对象</a>

<ul>
<li>
7.7.1: Anonymous objects | <a href="匿名对象.html">匿名对象</a>

<ul>
<li>
7.7.1.1: Subtleties with anonymous objects | <a href="匿名对象的微妙之处.html">匿名对象的微妙之处</a>

</ul>
</ul>
<li>
7.8: The keyword <code>inline</code> | <a href="关键字inline.html">关键字inline</a>

<ul>
<li>
7.8.1: Defining members inline | <a href="内联定义成员.html">内联定义成员</a>

<li>
7.8.2: When to use inline functions | <a href="何时使用内联函数.html">何时使用内联函数</a>

<ul>
<li>
7.8.2.1: A prelude: when NOT to use inline functions | <a href="前奏：何时不使用内联函数.html">前奏：何时不使用内联函数</a>

</ul>
<li>
7.8.3: Inline variables | <a href="内联变量.html">内联变量</a>

</ul>
<li>
7.9: Local classes: classes inside functions | <a href="局部类：函数内的类.html">局部类：函数内的类</a>

<li>
7.10: The keyword <code>mutable</code> | <a href="关键字mutable.html">关键字mutable</a>

<li>
7.11: Header file organization | <a href="头文件组织.html">头文件组织</a>

<ul>
<li>
7.11.1: Using namespaces in header files | <a href="在头文件中使用命名空间.html">在头文件中使用命名空间</a>

<li>
7.11.2: Modules | <a href="模块.html">模块</a>

</ul>
<li>
7.12: Sizeof applied to class data members | <a href="应用于类数据成员的大小.html">应用于类数据成员的大小</a>

</ul>
<li>
Chapter 8: Static Data And Functions | <a href="第8章 Static Data And Functions.html">第8章 Static Data And Functions</a>

<ul>
<li>
8.1: Static data | <a href="Static data.html">Static data</a>

<ul>
<li>
8.1.1: Private static data | <a href="私有静态数据.html">私有静态数据</a>

<li>
8.1.2: Public static data | <a href="公共静态数据.html">公共静态数据</a>

<li>
8.1.3: Initializing static const data | <a href="初始化静态常量数据.html">初始化静态常量数据</a>

<li>
8.1.4: Generalized constant expressions (constexpr) | <a href="广义常量表达式.html">广义常量表达式</a>

<ul>
<li>
8.1.4.1: Constant expression data | <a href="常量表达式数据.html">常量表达式数据</a>

</ul>
</ul>
<li>
8.2: Static member functions | <a href="静态成员函数.html">静态成员函数</a>

<ul>
<li>
8.2.1: Calling conventions | <a href="调用约定.html">调用约定</a>

</ul>
</ul>
<li>
Chapter 9: Classes And Memory Allocation | <a href="第9章 类和内存分配.html">第9章 类和内存分配</a>

<ul>
<li>
9.1: Operators <code>new</code> and <code>delete</code> | <a href="运算符和newdelete.html">运算符和newdelete</a>

<ul>
<li>
9.1.1: Allocating arrays | <a href="分配数组.html">分配数组</a>

<li>
9.1.2: Deleting arrays | <a href="删除数组.html">删除数组</a>

<li>
9.1.3: Enlarging arrays | <a href="放大数组.html">放大数组</a>

<li>
9.1.4: Managing <code>raw</code> memory | <a href="管理内存raw.html">管理内存raw</a>

<li>
9.1.5: The <code>placement new</code> operator | <a href="运算符placement new.html">运算符placement new</a>

</ul>
<li>
9.2: The destructor | <a href="析构函数.html">析构函数</a>

<ul>
<li>
9.2.1: Object pointers revisited | <a href="重新访问对象指针.html">重新访问对象指针</a>

<li>
9.2.2: The function set_new_handler() | <a href="函数 set_new_handler（）.html">函数 set_new_handler（）</a>

</ul>
<li>
9.3: The assignment operator | <a href="赋值运算符.html">赋值运算符</a>

<ul>
<li>
9.3.1: Overloading the assignment operator | <a href="重载赋值运算符.html">重载赋值运算符</a>

<ul>
<li>
9.3.1.1: The member <code>operator	()</code> | <a href="成员operator	().html">成员operator	()</a>

</ul>
</ul>
<li>
9.4: The <code>this</code> pointer | <a href="指针this.html">指针this</a>

<ul>
<li>
9.4.1: Sequential assignments and this | <a href="顺序赋值和此.html">顺序赋值和此</a>

</ul>
<li>
9.5: The copy constructor: initialization vs. assignment | <a href="复制构造函数：初始化与赋值.html">复制构造函数：初始化与赋值</a>

<li>
9.6: Revising the assignment operator | <a href="修改赋值运算符.html">修改赋值运算符</a>

<ul>
<li>
9.6.1: Swapping | <a href="交换.html">交换</a>

<ul>
<li>
9.6.1.1: Fast swapping | <a href="快速交换.html">快速交换</a>

</ul>
</ul>
<li>
9.7: Moving data | <a href="移动数据.html">移动数据</a>

<ul>
<li>
9.7.1: The move constructor (dynamic data) | <a href="移动构造函数（动态数据）.html">移动构造函数（动态数据）</a>

<li>
9.7.2: The move constructor (composition) | <a href="移动构造函数（组合）.html">移动构造函数（组合）</a>

<li>
9.7.3: Move-assignment | <a href="移动分配.html">移动分配</a>

<li>
9.7.4: Revising the assignment operator (part II) | <a href="修改赋值运算符（第二部分）.html">修改赋值运算符（第二部分）</a>

<li>
9.7.5: Moving and the destructor | <a href="移动和析构函数.html">移动和析构函数</a>

<li>
9.7.6: Move-only classes | <a href="仅移动类.html">仅移动类</a>

<li>
9.7.7: Default move constructors and assignment operators | <a href="默认移动构造函数和赋值运算符.html">默认移动构造函数和赋值运算符</a>

<li>
9.7.8: Moving: implications for class design | <a href="移动：对类设计的影响.html">移动：对类设计的影响</a>

</ul>
<li>
9.8: Copy Elision and Return Value Optimization | <a href="复制 ELISION 和返回值优化.html">复制 ELISION 和返回值优化</a>

<li>
9.9: Unrestricted Unions | <a href="不受限制的工会.html">不受限制的工会</a>

<ul>
<li>
9.9.1: Implementing the destructor | <a href="实现析构函数.html">实现析构函数</a>

<li>
9.9.2: Embedding an unrestricted union in a surrounding class | <a href="在周围类中嵌入不受限制的联合.html">在周围类中嵌入不受限制的联合</a>

<li>
9.9.3: Swapping unrestricted unions | <a href="交换不受限制的联合.html">交换不受限制的联合</a>

<li>
9.9.4: Assignment | <a href="分配.html">分配</a>

</ul>
<li>
9.10: Aggregate Data Types | <a href="聚合数据类型.html">聚合数据类型</a>

<li>
9.11: Conclusion | <a href="结论.html">结论</a>

</ul>
<li>
Chapter 10: Exceptions | <a href="第10章 异常.html">第10章 异常</a>

<ul>
<li>
10.1: Exception syntax | <a href="异常语法.html">异常语法</a>

<li>
10.2: An example using exceptions | <a href="使用异常的示例.html">使用异常的示例</a>

<ul>
<li>
10.2.1: Anachronisms: <code>setjmp</code> and <code>longjmp</code> | <a href="不合时宜：和setjmplongjmp.html">不合时宜：和setjmplongjmp</a>

<li>
10.2.2: Exceptions: the preferred alternative | <a href="例外：首选替代方案.html">例外：首选替代方案</a>

</ul>
<li>
10.3: Throwing exceptions | <a href="引发异常.html">引发异常</a>

<ul>
<li>
10.3.1: The empty <code>throw</code> statement | <a href="空throw语句.html">空throw语句</a>

</ul>
<li>
10.4: The try block | <a href="尝试块.html">尝试块</a>

<li>
10.5: Catching exceptions | <a href="捕获异常.html">捕获异常</a>

<ul>
<li>
10.5.1: The default catcher | <a href="默认捕手.html">默认捕手</a>

</ul>
<li>
10.6: Functions that cannot throw exceptions: the <code>noexcept</code> keyword | <a href="无法引发异常的函数：关键字noexcept.html">无法引发异常的函数：关键字noexcept</a>

<li>
10.7: Iostreams and exceptions | <a href="Io流和异常.html">Io流和异常</a>

<li>
10.8: Standard exceptions | <a href="标准例外.html">标准例外</a>

<ul>
<li>
10.8.1: Standard exceptions: to use or not to use? | <a href="标准例外：使用还是不使用？.html">标准例外：使用还是不使用？</a>

</ul>
<li>
10.9: System error, error_category, and error_condition | <a href="系统错误、error_category和error_condition.html">系统错误、error_category和error_condition</a>

<ul>
<li>
10.9.1: The class <code>std::error_category</code> | <a href="类std::error_category.html">类std::error_category</a>

<li>
10.9.2: The class <code>std::error_condition</code> | <a href="类std::error_condition.html">类std::error_condition</a>

<li>
10.9.3: The class system_error | <a href="类system_error.html">类system_error</a>

<li>
10.9.4: Exception propagation: std::exception_ptr | <a href="异常传播：标准：：exception_ptr.html">异常传播：标准：：exception_ptr</a>

</ul>
<li>
10.10: Exception guarantees | <a href="异常保证.html">异常保证</a>

<ul>
<li>
10.10.1: The basic guarantee | <a href="基本保证.html">基本保证</a>

<li>
10.10.2: The strong guarantee | <a href="强有力的保证.html">强有力的保证</a>

<li>
10.10.3: The nothrow guarantee | <a href="无掷空保证.html">无掷空保证</a>

</ul>
<li>
10.11: Function try blocks | <a href="函数尝试块.html">函数尝试块</a>

<li>
10.12: Exceptions in constructors and destructors | <a href="构造函数和析构函数中的异常.html">构造函数和析构函数中的异常</a>

</ul>
<li>
Chapter 11: More Operator Overloading | <a href="第11章 更多运算符重载.html">第11章 更多运算符重载</a>

<ul>
<li>
11.1: Overloading <code>operator[]()</code> | [[重载operator[]()]]

<li>
11.2: Overloading insertion and extraction operators | <a href="重载插入和提取运算符.html">重载插入和提取运算符</a>

<li>
11.3: Conversion operators | <a href="转换运算符.html">转换运算符</a>

<li>
11.4: The keyword <code>explicit</code> | <a href="关键字explicit.html">关键字explicit</a>

<ul>
<li>
11.4.1: Explicit conversion operators | <a href="显式转换运算符.html">显式转换运算符</a>

</ul>
<li>
11.5: Overloading increment and decrement operators | <a href="重载增量和递减运算符.html">重载增量和递减运算符</a>

<li>
11.6: Overloading binary operators | <a href="重载二元运算符.html">重载二元运算符</a>

<ul>
<li>
11.6.1: Member function reference bindings (&amp; and &amp;&amp;) | <a href="成员函数引用绑定（&amp;和&amp;&amp;）.html">成员函数引用绑定（&amp;和&amp;&amp;）</a>

<li>
11.6.2: The three-way comparison operator <code>&lt;	&gt;</code> | <a href="三向比较运算符&lt;	&gt;.html">三向比较运算符&lt;	&gt;</a>

</ul>
<li>
11.7: Overloading <code>operator new(size_t)</code> | <a href="重载operator new(size_t).html">重载operator new(size_t)</a>

<li>
11.8: Overloading <code>operator delete(void *)</code> | [[重载<code>operator delete(void *)</code>]]

<li>
11.9: Operators <code>new[]</code> and <code>delete[]</code> | [[运算符和new[]delete[]]]

<ul>
<li>
11.9.1: Overloading <code>new[]</code> | <a href="重载new[.html">重载new[</a>]

<li>
11.9.2: Overloading <code>delete[]</code> | <a href="重载delete[.html">重载delete[</a>]

<li>
11.9.3: The <code>operator delete(void *, size_t)</code> family | [[家庭<code>operator delete(void *, size_t)</code>]]

<li>
11.9.4: <code>new[]</code>, <code>delete[]</code> and exceptions | [[和异常new[]delete[]]]

</ul>
<li>
11.10: Function Objects | <a href="函数对象.html">函数对象</a>

<ul>
<li>
11.10.1: Constructing manipulators | <a href="构造机械手.html">构造机械手</a>

<ul>
<li>
11.10.1.1: Manipulators requiring arguments | <a href="需要参数的操纵器.html">需要参数的操纵器</a>

</ul>
</ul>
<li>
11.11: Lambda expressions | <a href="Lambda 表达式.html">Lambda 表达式</a>

<ul>
<li>
11.11.1: Lambda expressions: syntax | <a href="Lambda 表达式：语法.html">Lambda 表达式：语法</a>

<li>
11.11.2: Using lambda expressions | <a href="使用 lambda 表达式.html">使用 lambda 表达式</a>

</ul>
<li>
11.12: The case of [io]fstream::open() | [[[io]fstream：：open（） 的情况]]

<li>
11.13: User-defined literals | <a href="用户定义的文本.html">用户定义的文本</a>

<li>
11.14: Overloadable operators | <a href="可重载运算符.html">可重载运算符</a>

</ul>
<li>
Chapter 12: Abstract Containers | <a href="第12章 抽象容器.html">第12章 抽象容器</a>

<ul>
<li>
12.1: Notations used in this chapter | <a href="本章中使用的符号.html">本章中使用的符号</a>

<li>
12.2: The <code>pair</code> container | <a href="容器pair.html">容器pair</a>

<li>
12.3: Allocators | <a href="分配器.html">分配器</a>

<li>
12.4: Available Containers | <a href="可用容器.html">可用容器</a>

<ul>
<li>
12.4.1: The <code>array</code> container | <a href="容器array.html">容器array</a>

<li>
12.4.2: The <code>vector</code> container | <a href="容器vector.html">容器vector</a>

<li>
12.4.3: The <code>list</code> container | <a href="容器list.html">容器list</a>

<li>
12.4.4: The <code>queue</code> container | <a href="容器queue.html">容器queue</a>

<li>
12.4.5: The <code>priority_queue</code> container | <a href="容器priority_queue.html">容器priority_queue</a>

<li>
12.4.6: The <code>deque</code> container | <a href="容器deque.html">容器deque</a>

<li>
12.4.7: The <code>map</code> container | <a href="容器map.html">容器map</a>

<ul>
<li>
12.4.7.1: The <code>map</code> constructors | <a href="构造函数map.html">构造函数map</a>

<li>
12.4.7.2: The <code>map</code> operators | <a href="运算符map.html">运算符map</a>

<li>
12.4.7.3: The <code>map</code> public members | <a href="公共成员map.html">公共成员map</a>

<li>
12.4.7.4: The <code>map</code>: a simple example | <a href="：一个简单的例子map.html">：一个简单的例子map</a>

</ul>
<li>
12.4.8: The <code>multimap</code> container | <a href="容器multimap.html">容器multimap</a>

<li>
12.4.9: The <code>set</code> container | <a href="容器set.html">容器set</a>

<li>
12.4.10: The <code>multiset</code> container | <a href="容器multiset.html">容器multiset</a>

<li>
12.4.11: The <code>stack</code> container | <a href="容器stack.html">容器stack</a>

<li>
12.4.12: The <code>unordered_map</code> container (<code>hash table</code>) | <a href="容器 （unordered_maphash table).html">容器 （unordered_maphash table)</a>

<ul>
<li>
12.4.12.1: The <code>unordered_map</code> constructors | <a href="构造函数unordered_map.html">构造函数unordered_map</a>

<li>
12.4.12.2: The <code>unordered_map</code> public members | <a href="公共成员unordered_map.html">公共成员unordered_map</a>

<li>
12.4.12.3: The <code>unordered_multimap</code> container | <a href="容器unordered_multimap.html">容器unordered_multimap</a>

</ul>
<li>
12.4.13: The <code>unordered_set</code> container | <a href="容器unordered_set.html">容器unordered_set</a>

<ul>
<li>
12.4.13.1: The <code>unordered_multiset</code> container | <a href="容器unordered_multiset.html">容器unordered_multiset</a>

</ul>
<li>
12.4.14: Heterogeneous lookup | <a href="异构查找.html">异构查找</a>

</ul>
<li>
12.5: The <code>complex</code> container | <a href="容器complex.html">容器complex</a>

</ul>
<li>
Chapter 13: Inheritance | <a href="第13章 继承.html">第13章 继承</a>

<ul>
<li>
13.1: Related types | <a href="相关类型.html">相关类型</a>

<ul>
<li>
13.1.1: Inheritance depth: desirable? | <a href="继承深度：可取的？.html">继承深度：可取的？</a>

</ul>
<li>
13.2: Access rights: public, private, protected | <a href="访问权限：公共、私有、受保护.html">访问权限：公共、私有、受保护</a>

<ul>
<li>
13.2.1: Public, protected and private derivation | <a href="公共派生、受保护和私有派生.html">公共派生、受保护和私有派生</a>

<li>
13.2.2: Promoting access rights | <a href="提升访问权限.html">提升访问权限</a>

</ul>
<li>
13.3: The constructor of a derived class | <a href="派生类的构造函数.html">派生类的构造函数</a>

<ul>
<li>
13.3.1: Move construction | <a href="移动构造.html">移动构造</a>

<li>
13.3.2: Move assignment | <a href="移动分配.html">移动分配</a>

<li>
13.3.3: Inheriting constructors | <a href="继承构造函数.html">继承构造函数</a>

<li>
13.3.4: Aggregate Initializations | <a href="聚合初始化.html">聚合初始化</a>

</ul>
<li>
13.4: The destructor of a derived class | <a href="派生类的析构函数.html">派生类的析构函数</a>

<li>
13.5: Redefining member functions | <a href="重新定义成员函数.html">重新定义成员函数</a>

<li>
13.6: Multiple inheritance | <a href="多重继承.html">多重继承</a>

<li>
13.7: Conversions between base classes and derived classes | <a href="基类和派生类之间的转换.html">基类和派生类之间的转换</a>

<ul>
<li>
13.7.1: Conversions with object assignments | <a href="使用对象赋值进行转换.html">使用对象赋值进行转换</a>

<li>
13.7.2: Conversions with pointer assignments | <a href="使用指针赋值的转换.html">使用指针赋值的转换</a>

</ul>
<li>
13.8: Using non-default constructors with new[] | [[将非默认构造函数与 new[] 一起使用]]

</ul>
<li>
Chapter 14: Polymorphism | <a href="第14章 多态性.html">第14章 多态性</a>

<ul>
<li>
14.1: Virtual functions | <a href="虚拟函数.html">虚拟函数</a>

<li>
14.2: Virtual destructors | <a href="虚拟析构函数.html">虚拟析构函数</a>

<li>
14.3: Pure virtual functions | <a href="纯虚函数.html">纯虚函数</a>

<ul>
<li>
14.3.1: Implementing pure virtual functions | <a href="实现纯虚函数.html">实现纯虚函数</a>

</ul>
<li>
14.4: Explicit virtual overrides | <a href="显式虚拟覆盖.html">显式虚拟覆盖</a>

<li>
14.5: Virtual functions and multiple inheritance | <a href="虚函数和多重继承.html">虚函数和多重继承</a>

<ul>
<li>
14.5.1: Ambiguity in multiple inheritance | <a href="多重继承中的歧义.html">多重继承中的歧义</a>

<li>
14.5.2: Virtual base classes | <a href="虚拟基类.html">虚拟基类</a>

<li>
14.5.3: When virtual derivation is not appropriate | <a href="当虚拟派生不合适时.html">当虚拟派生不合适时</a>

</ul>
<li>
14.6: Run-time type identification | <a href="运行时类型标识.html">运行时类型标识</a>

<ul>
<li>
14.6.1: The dynamic_cast operator | <a href="dynamic_cast运算符.html">dynamic_cast运算符</a>

<li>
14.6.2: The <code>typeid</code> operator | <a href="运算符typeid.html">运算符typeid</a>

</ul>
<li>
14.7: Inheritance: when to use to achieve what? | <a href="继承：何时使用来实现什么？.html">继承：何时使用来实现什么？</a>

<li>
14.8: The <code>streambuf</code> class | <a href="类streambuf.html">类streambuf</a>

<ul>
<li>
14.8.1: Protected <code>streambuf</code> members | <a href="受保护的成员streambuf.html">受保护的成员streambuf</a>

<ul>
<li>
14.8.1.1: Protected members for input operations | <a href="输入操作的受保护成员.html">输入操作的受保护成员</a>

<li>
14.8.1.2: Protected members for output operations | <a href="输出操作的受保护成员.html">输出操作的受保护成员</a>

<li>
14.8.1.3: Protected members for buffer manipulation | <a href="用于缓冲区操作的受保护成员.html">用于缓冲区操作的受保护成员</a>

<li>
14.8.1.4: Deriving classes from <code>streambuf</code> | <a href="派生类自streambuf.html">派生类自streambuf</a>

</ul>
<li>
14.8.2: The class <code>filebuf</code> | <a href="类filebuf.html">类filebuf</a>

<li>
14.8.3: Safely interfacing streams to another std::streambuf | <a href="将流安全地连接到另一个 std：：streambuf.html">将流安全地连接到另一个 std：：streambuf</a>

</ul>
<li>
14.9: A polymorphic exception class | <a href="多态异常类.html">多态异常类</a>

<li>
14.10: How polymorphism is implemented | <a href="如何实现多态性.html">如何实现多态性</a>

<li>
14.11: Undefined reference to vtable ... | <a href="未定义对 vtable 的引用....html">未定义对 vtable 的引用...</a>

<li>
14.12: Virtual constructors | <a href="虚拟构造函数.html">虚拟构造函数</a>

</ul>
<li>
Chapter 15: Friends | <a href="第15章 朋友.html">第15章 朋友</a>

<ul>
<li>
15.1: Friend functions | <a href="好友函数.html">好友函数</a>

<li>
15.2: Extended friend declarations | <a href="扩展友元声明.html">扩展友元声明</a>

</ul>
<li>
Chapter 16: Classes Having Pointers To Members | <a href="第16章 具有指向成员的指针的类.html">第16章 具有指向成员的指针的类</a>

<ul>
<li>
16.1: Pointers to members: an example | <a href="指向成员的指针：示例.html">指向成员的指针：示例</a>

<li>
16.2: Defining pointers to members | <a href="定义指向成员的指针.html">定义指向成员的指针</a>

<li>
16.3: Using pointers to members | <a href="使用指向成员的指针.html">使用指向成员的指针</a>

<li>
16.4: Pointers to static members | <a href="指向静态成员的指针.html">指向静态成员的指针</a>

<li>
16.5: Pointer sizes | <a href="指针大小.html">指针大小</a>

</ul>
<li>
Chapter 17: Nested Classes | <a href="第17章 嵌套类.html">第17章 嵌套类</a>

<ul>
<li>
17.1: Defining nested class members | <a href="定义嵌套类成员.html">定义嵌套类成员</a>

<li>
17.2: Declaring nested classes | <a href="声明嵌套类.html">声明嵌套类</a>

<li>
17.3: Accessing private members in nested classes | <a href="访问嵌套类中的私有成员.html">访问嵌套类中的私有成员</a>

<li>
17.4: Nesting enumerations | <a href="嵌套枚举.html">嵌套枚举</a>

<ul>
<li>
17.4.1: Empty enumerations | <a href="空枚举.html">空枚举</a>

</ul>
<li>
17.5: Revisiting virtual constructors | <a href="重新审视虚拟构造函数.html">重新审视虚拟构造函数</a>

</ul>
<li>
Chapter 18: The Standard Template Library | <a href="第18章 标准模板库.html">第18章 标准模板库</a>

<ul>
<li>
18.1: Predefined function objects | <a href="预定义的函数对象.html">预定义的函数对象</a>

<ul>
<li>
18.1.1: Arithmetic function objects | <a href="算术函数对象.html">算术函数对象</a>

<li>
18.1.2: Relational function objects | <a href="关系函数对象.html">关系函数对象</a>

<li>
18.1.3: Logical function objects | <a href="逻辑函数对象.html">逻辑函数对象</a>

<li>
18.1.4: The <code>std::not_fn</code> negator | <a href="否定器std::not_fn.html">否定器std::not_fn</a>

</ul>
<li>
18.2: Iterators | <a href="迭代器.html">迭代器</a>

<ul>
<li>
18.2.1: std::distance and std::size | <a href="标准：:d和标准：：大小.html">标准：:d和标准：：大小</a>

<li>
18.2.2: Insert iterators | <a href="插入迭代器.html">插入迭代器</a>

<li>
18.2.3: Iterators for <code>istream</code> objects | <a href="对象的迭代器istream.html">对象的迭代器istream</a>

<ul>
<li>
18.2.3.1: Iterators for <code>istreambuf</code> objects | <a href="对象的迭代器istreambuf.html">对象的迭代器istreambuf</a>

</ul>
<li>
18.2.4: Iterators for <code>ostream</code> objects | <a href="对象的迭代器ostream.html">对象的迭代器ostream</a>

<ul>
<li>
18.2.4.1: Iterators for <code>ostreambuf</code> objects | <a href="对象的迭代器ostreambuf.html">对象的迭代器ostreambuf</a>

</ul>
<li>
18.2.5: Moving elements to another container | <a href="将元素移动到另一个容器.html">将元素移动到另一个容器</a>

</ul>
<li>
18.3: The class <code>unique_ptr</code> | <a href="类unique_ptr.html">类unique_ptr</a>

<ul>
<li>
18.3.1: Defining <code>unique_ptr</code> objects | <a href="定义对象unique_ptr.html">定义对象unique_ptr</a>

<li>
18.3.2: Creating a plain <code>unique_ptr</code> | <a href="创建普通unique_ptr.html">创建普通unique_ptr</a>

<li>
18.3.3: Moving another <code>unique_ptr</code> | <a href="移动另一个unique_ptr.html">移动另一个unique_ptr</a>

<li>
18.3.4: Pointing to a newly allocated object | <a href="指向新分配的对象.html">指向新分配的对象</a>

<li>
18.3.5: Operators and members | <a href="运算符和成员.html">运算符和成员</a>

<li>
18.3.6: Using <code>unique_ptr</code> objects for arrays | <a href="对数组使用对象unique_ptr.html">对数组使用对象unique_ptr</a>

</ul>
<li>
18.4: The class <code>shared_ptr</code> | <a href="类shared_ptr.html">类shared_ptr</a>

<ul>
<li>
18.4.1: Defining <code>shared_ptr</code> objects | <a href="定义对象shared_ptr.html">定义对象shared_ptr</a>

<li>
18.4.2: Creating a plain <code>shared_ptr</code> | <a href="创建普通shared_ptr.html">创建普通shared_ptr</a>

<li>
18.4.3: Pointing to a newly allocated object | <a href="指向新分配的对象.html">指向新分配的对象</a>

<li>
18.4.4: Operators and members | <a href="运算符和成员.html">运算符和成员</a>

<li>
18.4.5: Casting shared pointers | <a href="强制转换共享指针.html">强制转换共享指针</a>

<li>
18.4.6: Using <code>shared_ptr</code> objects for arrays | <a href="对数组使用对象shared_ptr.html">对数组使用对象shared_ptr</a>

</ul>
<li>
18.5: Smart <code>smart pointer</code> construction: <code>make_shared</code> and <code>make_unique</code> | <a href="智能建筑：和smart pointermake_sharedmake_unique.html">智能建筑：和smart pointermake_sharedmake_unique</a>

<li>
18.6: Classes having pointer data members | <a href="具有指针数据成员的类.html">具有指针数据成员的类</a>

<li>
18.7: Comparison classes | <a href="比较类.html">比较类</a>

<ul>
<li>
18.7.1: The class <code>weak_equality</code> | <a href="类weak_equality.html">类weak_equality</a>

<li>
18.7.2: The class <code>strong_equality</code> | <a href="类strong_equality.html">类strong_equality</a>

<li>
18.7.3: The class <code>partial_ordering</code> | <a href="类partial_ordering.html">类partial_ordering</a>

<li>
18.7.4: The class <code>weak_ordering</code> | <a href="类weak_ordering.html">类weak_ordering</a>

<li>
18.7.5: The class <code>strong_ordering</code> | <a href="类strong_ordering.html">类strong_ordering</a>

</ul>
<li>
18.8: Regular Expressions | <a href="正则表达式.html">正则表达式</a>

<ul>
<li>
18.8.1: The regular expression mini language | <a href="正则表达式迷你语言.html">正则表达式迷你语言</a>

<ul>
<li>
18.8.1.1: Character classes | <a href="字符类.html">字符类</a>

</ul>
<li>
18.8.2: Defining regular expressions: std::regex | <a href="定义正则表达式：std：：正则表达式.html">定义正则表达式：std：：正则表达式</a>

<li>
18.8.3: Retrieving matches: std::match_results | <a href="检索匹配项：标准：：match_results.html">检索匹配项：标准：：match_results</a>

<li>
18.8.4: Regular expression matching functions | <a href="正则表达式匹配函数.html">正则表达式匹配函数</a>

<ul>
<li>
18.8.4.1: The std::regex_constants::match_flag_type flags | <a href="标准：：regex_constants：：match_flag_type标志.html">标准：：regex_constants：：match_flag_type标志</a>

<li>
18.8.4.2: Matching full texts: std::regex_match | <a href="匹配全文：标准：：regex_match.html">匹配全文：标准：：regex_match</a>

<li>
18.8.4.3: Partially matching text: std::regex_search | <a href="部分匹配的文本：标准：：regex_search.html">部分匹配的文本：标准：：regex_search</a>

<li>
18.8.4.4: The member std::match_results::format | <a href="成员 std：：match_results：：格式.html">成员 std：：match_results：：格式</a>

<li>
18.8.4.5: Modifying target strings: std::regex_replace | <a href="修改目标字符串：标准：：regex_replace.html">修改目标字符串：标准：：regex_replace</a>

</ul>
</ul>
<li>
18.9: Randomization and Statistical Distributions | <a href="随机化和统计分布.html">随机化和统计分布</a>

<ul>
<li>
18.9.1: Random Number Generators | <a href="随机数生成器.html">随机数生成器</a>

<li>
18.9.2: Statistical distributions | <a href="统计分布.html">统计分布</a>

<ul>
<li>
18.9.2.1: Bernoulli distribution | <a href="伯努利分布.html">伯努利分布</a>

<li>
18.9.2.2: Binomial distribution | <a href="二项分布.html">二项分布</a>

<li>
18.9.2.3: Cauchy distribution | <a href="柯西分布.html">柯西分布</a>

<li>
18.9.2.4: Chi-squared distribution | <a href="卡方分布.html">卡方分布</a>

<li>
18.9.2.5: Extreme value distribution | <a href="极值分布.html">极值分布</a>

<li>
18.9.2.6: Exponential distribution | <a href="指数分布.html">指数分布</a>

<li>
18.9.2.7: Fisher F distribution | <a href="费舍尔 F 分布.html">费舍尔 F 分布</a>

<li>
18.9.2.8: Gamma distribution | <a href="伽马分布.html">伽马分布</a>

<li>
18.9.2.9: Geometric distribution | <a href="几何分布.html">几何分布</a>

<li>
18.9.2.10: Log-normal distribution | <a href="对数正态分布.html">对数正态分布</a>

<li>
18.9.2.11: Normal distribution | <a href="正态分布.html">正态分布</a>

<li>
18.9.2.12: Negative binomial distribution | <a href="负二项分布.html">负二项分布</a>

<li>
18.9.2.13: Poisson distribution | <a href="泊松分布.html">泊松分布</a>

<li>
18.9.2.14: Student t distribution | <a href="学生 t 分布.html">学生 t 分布</a>

<li>
18.9.2.15: Uniform int distribution | <a href="均匀的整数分布.html">均匀的整数分布</a>

<li>
18.9.2.16: Uniform real distribution | <a href="均匀实数分布.html">均匀实数分布</a>

<li>
18.9.2.17: Weibull distribution | <a href="威布尔分布.html">威布尔分布</a>

</ul>
</ul>
<li>
18.10: tie | <a href="平局.html">平局</a>

<li>
18.11: Optional return values | <a href="可选返回值.html">可选返回值</a>

</ul>
<li>
Chapter 19: The STL Generic Algorithms | <a href="第19章 STL泛型算法.html">第19章 STL泛型算法</a>

<ul>
<li>
19.1: The Generic Algorithms | <a href="通用算法.html">通用算法</a>

<ul>
<li>
19.1.1: Execution policies | <a href="执行策略.html">执行策略</a>

<li>
19.1.2: accumulate | <a href="累积.html">累积</a>

<li>
19.1.3: adjacent_difference | <a href="adjacent_difference.html">adjacent_difference</a>

<li>
19.1.4: adjacent_find | <a href="adjacent_find.html">adjacent_find</a>

<li>
19.1.5: all_of / any_of / none_of | <a href="all_of / any_of / none_of.html">all_of / any_of / none_of</a>

<li>
19.1.6: begin / end | <a href="开始/结束.html">开始/结束</a>

<li>
19.1.7: binary_search | <a href="binary_search.html">binary_search</a>

<li>
19.1.8: copy / copy_if | <a href="复制/copy_if.html">复制/copy_if</a>

<li>
19.1.9: copy_backward | <a href="copy_backward.html">copy_backward</a>

<li>
19.1.10: count / count_if | <a href="计数/count_if.html">计数/count_if</a>

<li>
19.1.11: equal | <a href="相等.html">相等</a>

<li>
19.1.12: equal_range | <a href="equal_range.html">equal_range</a>

<li>
19.1.13: exchange | <a href="交换.html">交换</a>

<li>
19.1.14: fill / fill_n | <a href="填充/fill_n.html">填充/fill_n</a>

<li>
19.1.15: find / find_if / find_if_not | <a href="查找 / find_if / find_if_not.html">查找 / find_if / find_if_not</a>

<li>
19.1.16: find_end | <a href="find_end.html">find_end</a>

<li>
19.1.17: find_first_of | <a href="find_first_of.html">find_first_of</a>

<li>
19.1.18: for_each | <a href="for_each.html">for_each</a>

<li>
19.1.19: generate / generate_n | <a href="生成/generate_n.html">生成/generate_n</a>

<li>
19.1.20: includes | <a href="包括.html">包括</a>

<li>
19.1.21: inner_product | <a href="inner_product.html">inner_product</a>

<li>
19.1.22: inplace_merge | <a href="inplace_merge.html">inplace_merge</a>

<li>
19.1.23: iota | <a href="物联网.html">物联网</a>

<li>
19.1.24: is_partitioned | <a href="is_partitioned.html">is_partitioned</a>

<li>
19.1.25: is_permutation | <a href="is_permutation.html">is_permutation</a>

<li>
19.1.26: is_sorted | <a href="is_sorted.html">is_sorted</a>

<li>
19.1.27: is_sorted_until | <a href="is_sorted_until.html">is_sorted_until</a>

<li>
19.1.28: iter_swap | <a href="iter_swap.html">iter_swap</a>

<li>
19.1.29: lexicographical_compare | <a href="lexicographical_compare.html">lexicographical_compare</a>

<li>
19.1.30: lower_bound | <a href="lower_bound.html">lower_bound</a>

<li>
19.1.31: max / min | <a href="最大值/分钟.html">最大值/分钟</a>

<li>
19.1.32: max_element / min_element / minmax_element | <a href="max_element / min_element / minmax_element.html">max_element / min_element / minmax_element</a>

<li>
19.1.33: merge | <a href="合并.html">合并</a>

<li>
19.1.34: minmax | <a href="最小最大值.html">最小最大值</a>

<li>
19.1.35: mismatch | <a href="不匹配.html">不匹配</a>

<li>
19.1.36: move / move_backward | <a href="移动/move_backward.html">移动/move_backward</a>

<li>
19.1.37: next_permutation / prev_permutation | <a href="next_permutation / prev_permutation.html">next_permutation / prev_permutation</a>

<li>
19.1.38: nth_element | <a href="nth_element.html">nth_element</a>

<li>
19.1.39: partial_sort / partial_sort_copy | <a href="partial_sort / partial_sort_copy.html">partial_sort / partial_sort_copy</a>

<li>
19.1.40: partial_sum | <a href="partial_sum.html">partial_sum</a>

<li>
19.1.41: partition / partition_point / stable_partition | <a href="分区 / partition_point / stable_partition.html">分区 / partition_point / stable_partition</a>

<li>
19.1.42: partition_copy | <a href="partition_copy.html">partition_copy</a>

<li>
19.1.43: reduce | <a href="减少.html">减少</a>

<li>
19.1.44: remove / remove_if / remove_copy / remove_copy_if | <a href="删除 / remove_if / remove_copy / remove_copy_if.html">删除 / remove_if / remove_copy / remove_copy_if</a>

<li>
19.1.45: replace / replace_if / replace_copy / replace_copy_if | <a href="替换 / replace_if / replace_copy / replace_copy_if.html">替换 / replace_if / replace_copy / replace_copy_if</a>

<li>
19.1.46: reverse / reverse_copy | <a href="反向/reverse_copy.html">反向/reverse_copy</a>

<li>
19.1.47: rotate / rotate_copy | <a href="旋转/rotate_copy.html">旋转/rotate_copy</a>

<li>
19.1.48: sample | <a href="示例.html">示例</a>

<li>
19.1.49: search / search_n | <a href="搜索/search_n.html">搜索/search_n</a>

<li>
19.1.50: set_difference | <a href="set_difference.html">set_difference</a>

<li>
19.1.51: set_intersection | <a href="set_intersection.html">set_intersection</a>

<li>
19.1.52: set_symmetric_difference | <a href="set_symmetric_difference.html">set_symmetric_difference</a>

<li>
19.1.53: set_union | <a href="set_union.html">set_union</a>

<li>
19.1.54: sort / stable_sort | <a href="排序/stable_sort.html">排序/stable_sort</a>

<li>
19.1.55: swap / swap_ranges | <a href="掉期/swap_ranges.html">掉期/swap_ranges</a>

<li>
19.1.56: transform | <a href="变换.html">变换</a>

<li>
19.1.57: transform_reduce | <a href="transform_reduce.html">transform_reduce</a>

<li>
19.1.58: handling uninitialized memory | <a href="处理未初始化的内存.html">处理未初始化的内存</a>

<li>
19.1.59: unique | <a href="唯一.html">唯一</a>

<li>
19.1.60: unique_copy | <a href="unique_copy.html">unique_copy</a>

<li>
19.1.61: upper_bound | <a href="upper_bound.html">upper_bound</a>

<li>
19.1.62: Heap algorithms | <a href="堆算法.html">堆算法</a>

<ul>
<li>
19.1.62.1: The <code>make_heap</code> function | <a href="函数make_heap.html">函数make_heap</a>

<li>
19.1.62.2: The <code>pop_heap</code> function | <a href="函数pop_heap.html">函数pop_heap</a>

<li>
19.1.62.3: The <code>push_heap</code> function | <a href="函数push_heap.html">函数push_heap</a>

<li>
19.1.62.4: The <code>sort_heap</code> function | <a href="函数sort_heap.html">函数sort_heap</a>

<li>
19.1.62.5: An example using the heap functions | <a href="使用堆函数的示例.html">使用堆函数的示例</a>

</ul>
</ul>
</ul>
<li>
Chapter 20: Multi Threading | <a href="第20章 多线程.html">第20章 多线程</a>

<ul>
<li>
20.1: Multi Threading | <a href="多线程.html">多线程</a>

<ul>
<li>
20.1.1: The namespace std::this_thread | <a href="命名空间 std：：this_thread.html">命名空间 std：：this_thread</a>

<li>
20.1.2: The class std::thread | <a href="类 std：：thread.html">类 std：：thread</a>

<ul>
<li>
20.1.2.1: Static data and threads: thread_local | <a href="静态数据和线程：thread_local.html">静态数据和线程：thread_local</a>

<li>
20.1.2.2: Exceptions and join() | <a href="异常和连接（）.html">异常和连接（）</a>

</ul>
<li>
20.1.3: The class std::jthread | <a href="类 std：：jthread.html">类 std：：jthread</a>

<ul>
<li>
20.1.3.1: std::stop_callback | <a href="标准：：stop_callback.html">标准：：stop_callback</a>

</ul>
</ul>
<li>
20.2: Synchronization (mutexes) | <a href="同步（互斥锁）.html">同步（互斥锁）</a>

<ul>
<li>
20.2.1: Initialization in multi-threaded programs | <a href="多线程程序中的初始化.html">多线程程序中的初始化</a>

<li>
20.2.2: Shared mutexes | <a href="共享互斥体.html">共享互斥体</a>

</ul>
<li>
20.3: Locks and lock handling | <a href="锁和锁处理.html">锁和锁处理</a>

<ul>
<li>
20.3.1: Deadlocks | <a href="死锁.html">死锁</a>

<li>
20.3.2: Shared locks | <a href="共享锁.html">共享锁</a>

<li>
20.3.3: Scoped locks | <a href="作用域锁.html">作用域锁</a>

</ul>
<li>
20.4: Event handling (condition variables) | <a href="事件处理（条件变量）.html">事件处理（条件变量）</a>

<ul>
<li>
20.4.1: The class std::condition_variable | <a href="类 std：：condition_variable.html">类 std：：condition_variable</a>

<li>
20.4.2: The class std::condition_variable_any | <a href="类 std：：condition_variable_any.html">类 std：：condition_variable_any</a>

<li>
20.4.3: An example using condition variables | <a href="使用条件变量的示例.html">使用条件变量的示例</a>

</ul>
<li>
20.5: Atomic actions: mutexes not required | <a href="原子操作：不需要互斥体.html">原子操作：不需要互斥体</a>

<li>
20.6: An example: threaded quicksort | <a href="示例：线程快速排序.html">示例：线程快速排序</a>

<li>
20.7: Shared States | <a href="共享状态.html">共享状态</a>

<li>
20.8: Asynchronous return objects: std::future | <a href="异步返回对象：std：：future.html">异步返回对象：std：：future</a>

<ul>
<li>
20.8.1: The std::future_error exception and the std::future_errc enum | <a href="std：：future_error 异常和 std：：future_errc 枚举.html">std：：future_error 异常和 std：：future_errc 枚举</a>

</ul>
<li>
20.9: Shared asynchronous return objects: std::shared_future | <a href="共享异步返回对象：std：：shared_future.html">共享异步返回对象：std：：shared_future</a>

<li>
20.10: Starting a new thread: std::async | <a href="启动新线程：标准：：异步.html">启动新线程：标准：：异步</a>

<li>
20.11: Preparing a task for execution: std::packaged_task | <a href="准备要执行的任务： std：:p ackaged_task.html">准备要执行的任务： std：:p ackaged_task</a>

<li>
20.12: The class <code>std::promise</code> | <a href="类std::promise.html">类std::promise</a>

<li>
20.13: An example: multi-threaded compilations | <a href="示例：多线程编译.html">示例：多线程编译</a>

<li>
20.14: Transactional Memory | <a href="事务内存.html">事务内存</a>

<li>
20.15: Synchronizing output to streams | <a href="将输出同步到流.html">将输出同步到流</a>

<ul>
<li>
20.15.1: The <code>std::syncbuf</code> streambuf | <a href="流std::syncbuf.html">流std::syncbuf</a>

<li>
20.15.2: Multi-threaded compilations using <code>osyncstream</code> | <a href="使用osyncstream.html">使用osyncstream</a>

</ul>
</ul>
<li>
Chapter 21: Function and Variable Templates | <a href="第21章 函数和变量模板.html">第21章 函数和变量模板</a>

<ul>
<li>
21.1: Defining function templates | <a href="定义函数模板.html">定义函数模板</a>

<ul>
<li>
21.1.1: Considerations regarding template parameters | <a href="有关模板参数的注意事项.html">有关模板参数的注意事项</a>

<li>
21.1.2: Auto and decltype | <a href="自动和分型.html">自动和分型</a>

<ul>
<li>
21.1.2.1: declval | <a href="十进制.html">十进制</a>

</ul>
<li>
21.1.3: Late-specified return type | <a href="后期指定的返回类型.html">后期指定的返回类型</a>

</ul>
<li>
21.2: Passing arguments by reference (reference wrappers) | <a href="通过引用传递参数（引用包装器）.html">通过引用传递参数（引用包装器）</a>

<li>
21.3: Using local and unnamed types as template arguments | <a href="使用本地和未命名类型作为模板参数.html">使用本地和未命名类型作为模板参数</a>

<li>
21.4: Template parameter deduction | <a href="模板参数推导.html">模板参数推导</a>

<ul>
<li>
21.4.1: Lvalue transformations | <a href="左值变换.html">左值变换</a>

<li>
21.4.2: Qualification transformations | <a href="资格转换.html">资格转换</a>

<li>
21.4.3: Transformation to a base class | <a href="转换为基类.html">转换为基类</a>

<li>
21.4.4: The template parameter deduction algorithm | <a href="模板参数推导算法.html">模板参数推导算法</a>

<li>
21.4.5: Template type contractions | <a href="模板类型收缩.html">模板类型收缩</a>

</ul>
<li>
21.5: Declaring function templates | <a href="声明函数模板.html">声明函数模板</a>

<ul>
<li>
21.5.1: Instantiation declarations | <a href="实例化声明.html">实例化声明</a>

</ul>
<li>
21.6: Instantiating function templates | <a href="实例化函数模板.html">实例化函数模板</a>

<ul>
<li>
21.6.1: Instantiations: no <code>code bloat</code> | <a href="实例化：否code bloat.html">实例化：否code bloat</a>

</ul>
<li>
21.7: Using explicit template types | <a href="使用显式模板类型.html">使用显式模板类型</a>

<li>
21.8: Overloading function templates | <a href="重载函数模板.html">重载函数模板</a>

<ul>
<li>
21.8.1: An example using overloaded function templates | <a href="使用重载函数模板的示例.html">使用重载函数模板的示例</a>

<li>
21.8.2: Ambiguities when overloading function templates | <a href="重载函数模板时的歧义.html">重载函数模板时的歧义</a>

<li>
21.8.3: Declaring overloaded function templates | <a href="声明重载函数模板.html">声明重载函数模板</a>

</ul>
<li>
21.9: Specializing templates for deviating types | <a href="用于偏离类型的专用模板.html">用于偏离类型的专用模板</a>

<ul>
<li>
21.9.1: Avoiding too many specializations | <a href="避免过多的专业化.html">避免过多的专业化</a>

<li>
21.9.2: Declaring specializations | <a href="声明专业化.html">声明专业化</a>

<li>
21.9.3: Complications when using the insertion operator | <a href="使用插入运算符时的复杂情况.html">使用插入运算符时的复杂情况</a>

</ul>
<li>
21.10: Static assertions | <a href="静态断言.html">静态断言</a>

<li>
21.11: Numeric limits | <a href="数值限制.html">数值限制</a>

<li>
21.12: Polymorphous wrappers for function objects | <a href="函数对象的多态包装器.html">函数对象的多态包装器</a>

<li>
21.13: Compiling template definitions and instantiations | <a href="编译模板定义和实例化.html">编译模板定义和实例化</a>

<li>
21.14: The function selection mechanism | <a href="函数选择机制.html">函数选择机制</a>

<ul>
<li>
21.14.1: Determining the template type parameters | <a href="确定模板类型参数.html">确定模板类型参数</a>

</ul>
<li>
21.15: SFINAE: Substitution Failure Is Not An Error | <a href="SFINAE：替换失败不是错误.html">SFINAE：替换失败不是错误</a>

<li>
21.16: Conditional function definitions using <code>if constexpr</code> | <a href="使用的条件函数定义if constexpr.html">使用的条件函数定义if constexpr</a>

<li>
21.17: Summary of the template declaration syntax | <a href="模板声明语法摘要.html">模板声明语法摘要</a>

<li>
21.18: Variables as templates (template variables) | <a href="变量作为模板（模板变量）.html">变量作为模板（模板变量）</a>

</ul>
<li>
Chapter 22: Class Templates | <a href="第22章：类模板.html">第22章：类模板</a>

<ul>
<li>
22.0.1: Template Argument Deduction | <a href="模板参数推导.html">模板参数推导</a>

<ul>
<li>
22.0.1.1: Simple Definitions | <a href="简单定义.html">简单定义</a>

<li>
22.0.1.2: Explicit Conversions | <a href="显式转换.html">显式转换</a>

</ul>
</ul>
<li>
22.1: Defining class templates | <a href="定义类模板.html">定义类模板</a>

<ul>
<li>
22.1.1: Constructing the circular queue: CirQue | <a href="构造循环队列：CirQue.html">构造循环队列：CirQue</a>

<li>
22.1.2: Non-type parameters | <a href="非类型参数.html">非类型参数</a>

<li>
22.1.3: Member templates | <a href="成员模板.html">成员模板</a>

<li>
22.1.4: CirQue's constructors and member functions | <a href="CirQu的构造函数和成员函数.html">CirQu的构造函数和成员函数</a>

<li>
22.1.5: Using CirQue objects | <a href="使用 CirQue 对象.html">使用 CirQue 对象</a>

<li>
22.1.6: Default class template parameters | <a href="默认类模板参数.html">默认类模板参数</a>

<li>
22.1.7: Declaring class templates | <a href="声明类模板.html">声明类模板</a>

<li>
22.1.8: Preventing template instantiations | <a href="防止模板实例化.html">防止模板实例化</a>

<li>
22.1.9: Generic lambda expressions | <a href="通用 lambda 表达式.html">通用 lambda 表达式</a>

</ul>
<li>
22.2: Static data members | <a href="静态数据成员.html">静态数据成员</a>

<ul>
<li>
22.2.1: Extended use of the keyword <code>typename</code> | <a href="关键字的扩展使用typename.html">关键字的扩展使用typename</a>

</ul>
<li>
22.3: Specializing class templates for deviating types | <a href="用于偏离类型的专用类模板.html">用于偏离类型的专用类模板</a>

<ul>
<li>
22.3.1: Example of a class specialization | <a href="类专业化示例.html">类专业化示例</a>

</ul>
<li>
22.4: Partial specializations | <a href="部分专业化.html">部分专业化</a>

<ul>
<li>
22.4.1: Intermezzo: some simple matrix algebraic concepts | <a href="间奏曲：一些简单的矩阵代数概念.html">间奏曲：一些简单的矩阵代数概念</a>

<li>
22.4.2: The Matrix class template | <a href="矩阵类模板.html">矩阵类模板</a>

<li>
22.4.3: The MatrixRow partial specialization | <a href="矩阵行部分专用化.html">矩阵行部分专用化</a>

<li>
22.4.4: The MatrixColumn partial specialization | <a href="矩阵列部分专用化.html">矩阵列部分专用化</a>

<li>
22.4.5: The 1x1 matrix: avoid ambiguity | <a href="1x1 矩阵：避免歧义.html">1x1 矩阵：避免歧义</a>

</ul>
<li>
22.5: Variadic templates | <a href="可变参数模板.html">可变参数模板</a>

<ul>
<li>
22.5.1: Defining and using variadic templates | <a href="定义和使用可变参数模板.html">定义和使用可变参数模板</a>

<li>
22.5.2: Perfect forwarding | <a href="完美转发.html">完美转发</a>

<li>
22.5.3: The unpack operator | <a href="解包运算符.html">解包运算符</a>

<li>
22.5.4: Non-type variadic templates | <a href="非类型可变参数模板.html">非类型可变参数模板</a>

<li>
22.5.5: Folding expressions | <a href="折叠表达式.html">折叠表达式</a>

</ul>
<li>
22.6: Tuples | <a href="元组.html">元组</a>

<ul>
<li>
22.6.1: Tuples and structured bindings | <a href="元组和结构化绑定.html">元组和结构化绑定</a>

</ul>
<li>
22.7: Computing the return type of function objects | <a href="计算函数对象的返回类型.html">计算函数对象的返回类型</a>

<li>
22.8: Instantiating class templates | <a href="实例化类模板.html">实例化类模板</a>

<li>
22.9: Processing class templates and instantiations | <a href="处理类模板和实例化.html">处理类模板和实例化</a>

<li>
22.10: Declaring friends | <a href="声明好友.html">声明好友</a>

<ul>
<li>
22.10.1: Non-templates used as friends in templates | <a href="在模板中用作好友的非模板.html">在模板中用作好友的非模板</a>

<li>
22.10.2: Templates instantiated for specific types as friends | <a href="实例化为特定类型的模板作为好友.html">实例化为特定类型的模板作为好友</a>

<ul>
<li>
22.10.2.1: Free operators as friends of nested classes | <a href="作为嵌套类的友元的自由运算符.html">作为嵌套类的友元的自由运算符</a>

</ul>
<li>
22.10.3: Unbound templates as friends | <a href="作为好友的未绑定模板.html">作为好友的未绑定模板</a>

<li>
22.10.4: Extended friend declarations | <a href="扩展友元声明.html">扩展友元声明</a>

</ul>
<li>
22.11: Class template derivation | <a href="类模板派生.html">类模板派生</a>

<ul>
<li>
22.11.1: Deriving ordinary classes from class templates | <a href="从类模板派生普通类.html">从类模板派生普通类</a>

<li>
22.11.2: Deriving class templates from class templates | <a href="从类模板派生类模板.html">从类模板派生类模板</a>

<li>
22.11.3: Deriving class templates from ordinary classes | <a href="从普通类派生类模板.html">从普通类派生类模板</a>

</ul>
<li>
22.12: Static Polymorphism | <a href="静态多态性.html">静态多态性</a>

<ul>
<li>
22.12.1: An example of static polymorphism | <a href="静态多态性示例.html">静态多态性示例</a>

<li>
22.12.2: Converting dynamic polymorphic classes to static polymorphic classes | <a href="将动态多态类转换为静态多态类.html">将动态多态类转换为静态多态类</a>

<li>
22.12.3: Using static polymorphism to avoid reimplementations | <a href="使用静态多态性避免重新实现.html">使用静态多态性避免重新实现</a>

</ul>
<li>
22.13: Class templates and nesting | <a href="类模板和嵌套.html">类模板和嵌套</a>

<li>
22.14: Constructing iterators | <a href="构造迭代器.html">构造迭代器</a>

<ul>
<li>
22.14.1: Implementing a <code>RandomAccessIterator</code> | <a href="实现RandomAccessIterator.html">实现RandomAccessIterator</a>

<li>
22.14.2: Implementing a <code>reverse_iterator</code> | <a href="实现reverse_iterator.html">实现reverse_iterator</a>

</ul>
<li>
Chapter 23: Advanced Template Use | <a href="第23章 高级模板使用.html">第23章 高级模板使用</a>

<ul>
<li>
23.1: Subtleties | <a href="微妙之处.html">微妙之处</a>

<ul>
<li>
23.1.1: Type resolution for base class members | <a href="基类成员的类型解析.html">基类成员的类型解析</a>

<li>
23.1.2: ::template, .template and -&gt;template | <a href="：：模板、.模板和 -&gt;模板.html">：：模板、.模板和 -&gt;模板</a>

</ul>
<li>
23.2: Template Meta Programming | <a href="模板元编程.html">模板元编程</a>

<ul>
<li>
23.2.1: Values according to templates | <a href="根据模板的值.html">根据模板的值</a>

<ul>
<li>
23.2.1.1: Converting integral types to types | <a href="将整型转换为类型.html">将整型转换为类型</a>

</ul>
<li>
23.2.2: Selecting alternatives using templates | <a href="使用模板选择备选方案.html">使用模板选择备选方案</a>

<ul>
<li>
23.2.2.1: Defining overloading members | <a href="定义重载成员.html">定义重载成员</a>

<li>
23.2.2.2: Class structure as a function of template parameters | <a href="作为模板参数函数的类结构.html">作为模板参数函数的类结构</a>

<li>
23.2.2.3: An illustrative example | <a href="说明性示例.html">说明性示例</a>

</ul>
<li>
23.2.3: Templates: Iterations by Recursion | <a href="模板：递归迭代.html">模板：递归迭代</a>

</ul>
<li>
23.3: User-defined literals | <a href="用户定义的文本.html">用户定义的文本</a>

<li>
23.4: Template template parameters | <a href="模板模板参数.html">模板模板参数</a>

<ul>
<li>
23.4.1: Policy classes - I | <a href="策略类 - I.html">策略类 - I</a>

<li>
23.4.2: Policy classes - II: template template parameters | <a href="策略类 - II：模板模板参数.html">策略类 - II：模板模板参数</a>

<ul>
<li>
23.4.2.1: The destructor of Policy classes | <a href="策略类的析构函数.html">策略类的析构函数</a>

</ul>
<li>
23.4.3: Structure by Policy | <a href="按策略构建.html">按策略构建</a>

</ul>
<li>
23.5: Alias Templates | <a href="别名模板.html">别名模板</a>

<li>
23.6: Trait classes | <a href="特质类.html">特质类</a>

<ul>
<li>
23.6.1: Distinguishing class from non-class types | <a href="区分类和非类类型.html">区分类和非类类型</a>

<li>
23.6.2: Available type traits | <a href="可用的类型特征.html">可用的类型特征</a>

</ul>
<li>
23.7: Defining <code>ErrorCodeEnum</code> and <code>ErrorConditionEnum</code> enumerations | <a href="定义和枚举ErrorCodeEnumErrorConditionEnum.html">定义和枚举ErrorCodeEnumErrorConditionEnum</a>

<ul>
<li>
23.7.1: Deriving classes from std::error_category | <a href="从 std：：error_category 派生类.html">从 std：：error_category 派生类</a>

</ul>
<li>
23.8: Using <code>noexcept</code> when offering the <code>strong guarantee</code> | <a href="在提供noexceptstrong guarantee.html">在提供noexceptstrong guarantee</a>

<li>
23.9: More conversions to class types | <a href="更多类类型的转化.html">更多类类型的转化</a>

<ul>
<li>
23.9.1: Types to types | <a href="类型到类型.html">类型到类型</a>

<li>
23.9.2: An empty type | <a href="空类型.html">空类型</a>

<li>
23.9.3: Type convertibility | <a href="类型可转换性.html">类型可转换性</a>

<ul>
<li>
23.9.3.1: Determining inheritance | <a href="确定继承.html">确定继承</a>

</ul>
</ul>
<li>
23.10: Template TypeList processing | <a href="模板类型列表处理.html">模板类型列表处理</a>

<ul>
<li>
23.10.1: The length of a TypeList | <a href="类型列表的长度.html">类型列表的长度</a>

<li>
23.10.2: Searching a TypeList | <a href="搜索类型列表.html">搜索类型列表</a>

<li>
23.10.3: Selecting from a TypeList | <a href="从类型列表中选择.html">从类型列表中选择</a>

<li>
23.10.4: Prefixing/Appending to a TypeList | <a href="前缀/追加到类型列表.html">前缀/追加到类型列表</a>

<li>
23.10.5: Erasing from a TypeList | <a href="从类型列表中擦除.html">从类型列表中擦除</a>

<ul>
<li>
23.10.5.1: Erasing the first occurrence | <a href="擦除第一个匹配项.html">擦除第一个匹配项</a>

<li>
23.10.5.2: Erasing a type by its index | <a href="按索引擦除类型类型.html">按索引擦除类型类型</a>

<li>
23.10.5.3: Erasing all occurrences of a type | <a href="擦除某个类型的所有匹配项.html">擦除某个类型的所有匹配项</a>

<li>
23.10.5.4: Erasing duplicates | <a href="擦除重复项.html">擦除重复项</a>

</ul>
</ul>
<li>
23.11: Using a TypeList | <a href="使用类型列表.html">使用类型列表</a>

<ul>
<li>
23.11.1: The Wrap and Multi class templates | <a href="包装和多类模板.html">包装和多类模板</a>

<li>
23.11.2: The MultiBase class template | <a href="多基类模板.html">多基类模板</a>

<li>
23.11.3: Support templates | <a href="支持模板.html">支持模板</a>

<li>
23.11.4: Using Multi | <a href="使用多.html">使用多</a>

</ul>
<li>
23.12: Expression Templates | <a href="表达式模板.html">表达式模板</a>

<ul>
<li>
23.12.1: Designing an Expression Template | <a href="设计表达式模板.html">设计表达式模板</a>

<li>
23.12.2: Implementing an Expression Template | <a href="实现表达式模板.html">实现表达式模板</a>

<li>
23.12.3: The BasicType trait class and ordering classes | <a href="基本类型特征类和排序类.html">基本类型特征类和排序类</a>

</ul>
<li>
23.13: Concepts | <a href="概念.html">概念</a>

<ul>
<li>
23.13.1: Defining concepts | <a href="定义概念.html">定义概念</a>

<li>
23.13.2: Requirements | <a href="要求.html">要求</a>

<ul>
<li>
23.13.2.1: Simple requirements | <a href="简单要求.html">简单要求</a>

<li>
23.13.2.2: Type requirements | <a href="类型要求.html">类型要求</a>

<li>
23.13.2.3: Compound requirements | <a href="化合物要求.html">化合物要求</a>

<li>
23.13.2.4: Nested requirements | <a href="嵌套要求.html">嵌套要求</a>

</ul>
<li>
23.13.3: Predefined concepts | <a href="预定义概念.html">预定义概念</a>

<ul>
<li>
23.13.3.1: Concepts specifying one template type parameter | <a href="指定一个模板类型参数的概念.html">指定一个模板类型参数的概念</a>

<li>
23.13.3.2: Concepts specifying two template type parameters | <a href="指定两个模板类型参数的概念.html">指定两个模板类型参数的概念</a>

<li>
23.13.3.3: Concepts specifying multiple template type parameters | <a href="指定多个模板类型参数的概念.html">指定多个模板类型参数的概念</a>

</ul>
<li>
23.13.4: Applying concepts to template parameter packs | <a href="将概念应用于模板参数包.html">将概念应用于模板参数包</a>

<li>
23.13.5: Applying concepts to free functions | <a href="将概念应用于自由函数.html">将概念应用于自由函数</a>

<li>
23.13.6: Implementing constrained class members | <a href="实现受约束的类成员.html">实现受约束的类成员</a>

<li>
23.13.7: Constrained partial specializations | <a href="受约束的部分专业化.html">受约束的部分专业化</a>

<ul>
<li>
23.13.7.1: Function- and class template declarations | <a href="函数模板和类模板声明.html">函数模板和类模板声明</a>

<li>
23.13.7.2: Bound free-operators | <a href="绑定自由算子.html">绑定自由算子</a>

</ul>
</ul>
</ul>
<li>
Chapter 24: Coroutines | <a href="第24章 协程.html">第24章 协程</a>

<ul>
<li>
24.1: Defining a coroutine | <a href="定义协程.html">定义协程</a>

<ul>
<li>
24.1.1: The coroutine's State class (promise_type) | <a href="协程的状态类 （promise_type）.html">协程的状态类 （promise_type）</a>

<ul>
<li>
24.1.1.1: What if <code>suspend_never</code> is used? | <a href="如果使用怎么办？suspend_never.html">如果使用怎么办？suspend_never</a>

</ul>
<li>
24.1.2: Simplifying the state class | <a href="简化状态类.html">简化状态类</a>

</ul>
<li>
24.2: Embedding coroutines in classes | <a href="在类中嵌入协程.html">在类中嵌入协程</a>

<ul>
<li>
24.2.1: The <code>Reader</code> coroutine handler | <a href="协程处理程序Reader.html">协程处理程序Reader</a>

<li>
24.2.2: The <code>Writer</code> coroutine handler | <a href="协程处理程序Writer.html">协程处理程序Writer</a>

</ul>
<li>
24.3: <code>Awaitables</code>, <code>Awaiters</code> and <code>co_await</code> | <a href="和AwaitablesAwaitersco_await.html">和AwaitablesAwaitersco_await</a>

<li>
24.4: The class <code>Awaiter</code> | <a href="类Awaiter.html">类Awaiter</a>

<li>
24.5: Accessing State from inside coroutines | <a href="从协程内部访问状态.html">从协程内部访问状态</a>

<li>
24.6: Finite State Automatons via coroutines | <a href="通过协程的有限状态自动机.html">通过协程的有限状态自动机</a>

<ul>
<li>
24.6.1: The <code>Start</code> handler class | <a href="处理程序类Start.html">处理程序类Start</a>

<li>
24.6.2: Completing the Finite State Automaton | <a href="完成有限状态自动机.html">完成有限状态自动机</a>

</ul>
<li>
24.7: Recursive coroutines | <a href="递归协程.html">递归协程</a>

<ul>
<li>
24.7.1: Recursively calling recursiveCoro | <a href="递归调用递归Coro.html">递归调用递归Coro</a>

<li>
24.7.2: Beyond a single recursive call | <a href="超越单个递归调用.html">超越单个递归调用</a>

</ul>
<li>
24.8: Coroutine iterators | <a href="协程迭代器.html">协程迭代器</a>

<li>
24.9: Visiting directories using coroutines | <a href="使用协程访问目录.html">使用协程访问目录</a>

<ul>
<li>
24.9.1: The <code>Dir</code> class showing directory entries | <a href="显示目录条目的类Dir.html">显示目录条目的类Dir</a>

<li>
24.9.2: Visiting directories using coroutines | <a href="使用协程访问目录.html">使用协程访问目录</a>

<li>
24.9.3: Functions vs. coroutines | <a href="函数与协程.html">函数与协程</a>

</ul>
</ul>
<li>
Chapter 25: Concrete Examples | <a href="第25章 具体例子.html">第25章 具体例子</a>

<ul>
<li>
25.1: Using file descriptors with <code>streambuf</code> classes | <a href="对类使用文件描述符streambuf.html">对类使用文件描述符streambuf</a>

<ul>
<li>
25.1.1: Classes for output operations | <a href="输出操作的类.html">输出操作的类</a>

<li>
25.1.2: Classes for input operations | <a href="输入操作的类.html">输入操作的类</a>

<ul>
<li>
25.1.2.1: Using a one-character buffer | <a href="使用单字符缓冲区.html">使用单字符缓冲区</a>

<li>
25.1.2.2: Using an n-character buffer | <a href="使用 n 字符缓冲区.html">使用 n 字符缓冲区</a>

<li>
25.1.2.3: Seeking positions in <code>streambuf</code> objects | <a href="在物体中寻找位置streambuf.html">在物体中寻找位置streambuf</a>

<li>
25.1.2.4: Multiple <code>unget</code> calls in <code>streambuf</code> objects | <a href="对象中的多个调用ungetstreambuf.html">对象中的多个调用ungetstreambuf</a>

</ul>
<li>
25.1.3: Fixed-sized field extraction from istream objects | <a href="从 istream 对象中提取固定大小的字段.html">从 istream 对象中提取固定大小的字段</a>

<ul>
<li>
25.1.3.1: Member functions and example | <a href="成员函数和示例.html">成员函数和示例</a>

</ul>
</ul>
<li>
25.2: The <code>fork</code> system call | <a href="系统调用fork.html">系统调用fork</a>

<ul>
<li>
25.2.1: A basic Fork class | <a href="一个基本的 Fork 类.html">一个基本的 Fork 类</a>

<li>
25.2.2: Parents and Children | <a href="父母和孩子.html">父母和孩子</a>

<li>
25.2.3: Redirection revisited | <a href="重新审视重定向.html">重新审视重定向</a>

<li>
25.2.4: The <code>Daemon</code> program | <a href="程序Daemon.html">程序Daemon</a>

<li>
25.2.5: The class <code>Pipe</code> | <a href="类Pipe.html">类Pipe</a>

<li>
25.2.6: The class <code>ParentSlurp</code> | <a href="类ParentSlurp.html">类ParentSlurp</a>

<li>
25.2.7: Communicating with multiple children | <a href="与多个孩子沟通.html">与多个孩子沟通</a>

<ul>
<li>
25.2.7.1: The class <code>Selector</code>: interface | <a href="类 ： 接口Selector.html">类 ： 接口Selector</a>

<li>
25.2.7.2: The class <code>Selector</code>: implementation | <a href="类：实现Selector.html">类：实现Selector</a>

<li>
25.2.7.3: The class <code>Monitor</code>: interface | <a href="类 ： 接口Monitor.html">类 ： 接口Monitor</a>

<li>
25.2.7.4: The class <code>Monitor</code>: s_handler | <a href="类：s_handlerMonitor.html">类：s_handlerMonitor</a>

<li>
25.2.7.5: The class <code>Monitor</code>: the member <code>run</code> | <a href="类：杆件Monitorrun.html">类：杆件Monitorrun</a>

<li>
25.2.7.6: The class <code>Monitor</code>: example | <a href="类 ： 示例Monitor.html">类 ： 示例Monitor</a>

<li>
25.2.7.7: The class <code>Child</code> | <a href="类Child.html">类Child</a>

</ul>
</ul>
<li>
25.3: Adding binary operators to classes | <a href="向类添加二元运算符.html">向类添加二元运算符</a>

<ul>
<li>
25.3.1: Merely using operators | <a href="仅使用运算符.html">仅使用运算符</a>

<ul>
<li>
25.3.1.1: To namespace or not to namespace? | <a href="到命名空间还是不到命名空间？.html">到命名空间还是不到命名空间？</a>

</ul>
<li>
25.3.2: The CRTP and defining operator function templates | <a href="CRTP 和定义运算符函数模板.html">CRTP 和定义运算符函数模板</a>

<li>
25.3.3: Insertion and extraction | <a href="插入和拔出.html">插入和拔出</a>

</ul>
<li>
25.4: Distinguishing lvalues from rvalues with operator[]() | [[使用运算符 []（） 区分左值和右值]]

<li>
25.5: Implementing a <code>reverse_iterator</code> | <a href="实现reverse_iterator.html">实现reverse_iterator</a>

<li>
25.6: Using <code>bisonc++</code> and <code>flexc++</code> | <a href="使用 和bisonc++flexc++.html">使用 和bisonc++flexc++</a>

<ul>
<li>
25.6.1: Using <code>flexc++</code> to create a scanner | <a href="用于创建扫描程序flexc++.html">用于创建扫描程序flexc++</a>

<ul>
<li>
25.6.1.1: The derived class <code>Scanner</code> | <a href="派生类Scanner.html">派生类Scanner</a>

<li>
25.6.1.2: The lexical scanner specification file | <a href="词法扫描程序规范文件.html">词法扫描程序规范文件</a>

<li>
25.6.1.3: Implementing <code>Scanner</code> | <a href="实现Scanner.html">实现Scanner</a>

<li>
25.6.1.4: Using a <code>Scanner</code> object | <a href="使用对象Scanner.html">使用对象Scanner</a>

<li>
25.6.1.5: Building the program | <a href="构建程序.html">构建程序</a>

</ul>
<li>
25.6.2: Using <code>bisonc++</code> and <code>flexc++</code> | <a href="使用 bisonc++ 和flexc++.html">使用 bisonc++ 和flexc++</a>

<ul>
<li>
25.6.2.1: The <code>bisonc++</code> specification file | <a href="规范文件 bisonc++.html">规范文件 bisonc++</a>

<li>
25.6.2.2: The <code>flexc++</code> specification file | <a href="规范文件 flexc++.html">规范文件 flexc++</a>

<li>
25.6.2.3: Building the program | <a href="构建程序.html">构建程序</a>

</ul>
</ul>
</ul>
</ul>

</body>
</html>
