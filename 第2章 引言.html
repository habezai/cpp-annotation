<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>第2章 引言</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<p>
Table of Contents | <a href="index.html">目录主页</a>
</p>

<p>
Previous Chapter | <a href="第1章 章节概述.html">上一章</a>
</p>

<p>
Next Chapter | <a href="第3章 C++的第一印象.html">下一章</a>
</p>

<hr />

<p>
本文档介绍了C++编程语言。这是一份C/C++编程课程指南，由Frank教授在格罗宁根大学上每年发布一次。
这个文档并不是一个完整的 C/C++ 手册，因为很多 C++ 背景知识都没有涉及到。<br > 
其他的资料也可以参考(例如，George Danchev 推荐给我的<a href="http://publications.gbdirect.co.uk/c_book/">在线书籍</a>)。
</p>

<p>
读者应该预先被警告，实际上是假定对 C 编程语言有广泛的了解。
C++ 注释在 C 编程语言的主题结束的地方继续，例如: 指针、基本流程控制和函数构造。
</p>

<p>
语言的某些元素，比如特定的词法标记(比如digraphs(例如 &lt;: for [ 和 &gt;: for ] ，不包含在 C++ 注释中，因为这些标记在 C++ 源代码中极少出现。此外，已经从 C++ 中删除了trigraphs( 使用 ??&lt; for { 和 ??&gt; for } )。
</p>

<p>
C++ 标准的工作草案可以免费获得，并且可以从git 仓库克隆: <a href="https://gitlab.com/cplusplus/draft.git">https://gitlab.com/cplusplus/draft.git</a> 。
</p>

<p>
C++ 注释的版本号(目前为12.3.1)在文档内容更改时更新。第一个数字是主要的数字，并且可能在一段时间内不会改变: 它表示一个重大的改写。当向文档中添加新信息时，中间数会增加。最后一个数字只表示小的变化; 当一系列的拼写错误被纠正时，它就会增加。
</p>

<p>
本文件由荷兰格罗宁根大学信息技术中心 GNU通用公共许可协议发布。
</p>


<hr />

<p>
在本章中，我们将概述 C++ 的定义特性。回顾了 C 语言的一些扩展，并简要介绍了基于对象和面向对象编程(OOP)的概念。
</p>

<div id="2.1: C++注释中的新增功能"><h1 id="2.1: C++注释中的新增功能" class="header"><a href="#2.1: C++注释中的新增功能">2.1: C++注释中的新增功能</a></h1></div>

<div id="2.2: C++的历史"><h1 id="2.2: C++的历史" class="header"><a href="#2.2: C++的历史">2.2: C++的历史</a></h1></div>

<p>
C++ 是一种编程语言，最早于20世纪80年代在AT&amp;T贝尔实验室开发，当时该实验室也是Unix操作系统的诞生地。
</p>

<p>
C++ 最初是一个“预编译器”pre-compiler，类似于 C 的预处理器preprocessor，将源代码中的特殊结构转换为纯C语言。当时，这些代码是由标准的 C 编译器来编译的。由 C++ 预编译器读取的“pre-code”通常存储在扩展名为 .cc、.C 或 .cpp 的文件中。该文件随后将被转换为扩展名为 .c 的C语言源文件，然后进行编译和链接。
</p>

<p>
C++ 源文件的命名法仍然存在：扩展名.cc和.cpp仍使用。但是，如今通常在实际编译过程中执行 C++ 预编译器的初步工作。编译器通常根据其扩展名确定源文件中使用的语言。这适用于 Borland 和 Microsoft 的 C++ 编译器，它们假定扩展名 .cpp 表示C++源文件。GNU编译器g++（在许多Unix平台上可用）则假定 扩展名.cc 表示C++。
</p>

<p>
从 C++ 是 C 的超集这一事实也可以看出 C++ 曾经被编译成 C 代码的事实：C++ 提供了完整的 C 语法并支持所有 C 库函数，并添加了它自己的特性。这使得从 C 到 C++ 的转换非常容易。熟悉 C 的程序员可以通过使用扩展名为 .cc 或 .cpp 而不是 .c 的源文件开始“使用 C++ ”，然后可以轻松地体验 C++ 提供的所有可能性。不需要突然改变习惯。
</p>

<div id="2.2: C++的历史-2.2.1: C++注释的历史"><h2 id="2.2.1: C++注释的历史" class="header"><a href="#2.2: C++的历史-2.2.1: C++注释的历史">2.2.1: C++注释的历史</a></h2></div>
<p>
C++ Annotations最初由Frank Brokken和Karel Kubat用荷兰语使用LaTeX编写。
后来，Karel在1994年9月将文本重新编写并转换为更适合的格式和英语。
</p>

<p>
1994年10月，指南的第一个版本出现在网络上。此时，它已转换为SGML格式。
逐渐添加了新章节，并修改和进一步改进了内容（感谢无数读者发送的评论）。
</p>

<p>
在主版本四中，Frank添加了新的章节并将文档从SGML转换为yodl。
C++ Annotations可自由分发。请务必阅读法律声明。
</p>

<p>
继续阅读本文档意味着您已经了解了这些声明并同意它们。
如果您喜欢这个文档，请告诉您的朋友。更好的做法是通过发送电子邮件给Frank来让我们知道。
</p>

<div id="2.2: C++的历史-2.2.2: 使用C++编译器编译 C 程序"><h2 id="2.2.2: 使用C++编译器编译 C 程序" class="header"><a href="#2.2: C++的历史-2.2.2: 使用C++编译器编译 C 程序">2.2.2: 使用C++编译器编译 C 程序</a></h2></div>

<p>
C++不是C语言的完美超集。当将文件重命名为具有扩展名 .cc 的文件并通过C++编译器运行时，可能会遇到一些不同之处。<br	>
在C语言中，sizeof('c') 等于 sizeof(int)，其中 'c' 是任何ASCII字符。这是因为当将char类型的参数传递给函数时，它们会被作为整数传递。此外，C编译器将字符常量（如 'c'）处理为整数常量。因此，在C语言中，函数调用 putchar(10) 和 putchar('\n') 是同义的。
</p>

<p>
相反，在C++中，sizeof('c') 始终为1（但请参见<a href="第3章 C++的第一印象.html#3.4.2: The data type wchar_t ">第3.4.2节</a>）。int仍然是int类型。我们将在稍后（<a href="第2章 引言.html#2.5.4: 函数重载">第2.5.4节</a>）看到，两个函数调用somefunc(10)和somefunc('\n')可能由不同的函数处理：C++不仅通过名称区分函数，还通过它们的参数类型进行区分，而这两个调用中的参数类型是不同的。前者使用int类型的参数，后者使用char类型的参数。 
</p>
<pre><code>somefunc(10);
</code></pre>
<p>
和
</p>
<pre><code>somefunc('\n');
</code></pre>
	

<p>
C++要求对外部函数进行非常严格的原型设计。例如，在C语言中，像
</p>
<pre><code>void func();
</code></pre>
<p>
这样的原型表示存在一个名为func()的函数，它不返回任何值。该声明未指定函数接受哪些参数（如果有）。
</p>

<p>
然而，在C++中，上述声明意味着函数func()根本 <span id="2.2: C++的历史-2.2.2: 使用C++编译器编译 C 程序-不接受任何参数"></span><strong id="不接受任何参数">不接受任何参数</strong> 。向该函数传递任何参数都会导致编译时错误。
</p>

<p>
注意，在声明函数时不需要使用关键字extern。通过用分号替换函数的主体，函数定义就成了函数声明。但是，在声明变量时需要使用关键字extern。
</p>

<div id="2.2: C++的历史-2.2.3: 编译C++程序"><h2 id="2.2.3: 编译C++程序" class="header"><a href="#2.2: C++的历史-2.2.3: 编译C++程序">2.2.3: 编译C++程序</a></h2></div>
<ul>
<li>
为了编译 C++ 程序，需要使用一个 C++ 编译器。 考虑到本文是免费的，因此推荐使用免费的编译器。

<li>
Free Software Foundation (FSF) 提供了一个免费的 C++ 编译器，可以在 <a href="http://www.gnu.org">http://www.gnu.org</a> 上获取。 该编译器也是 Linux 发行版 Debian (<a href="http://www.debian.org)">http://www.debian.org)</a> 的一部分。

<li>
要激活 C++17 标准，请使用标志 --std=c++17。 在 C++ Annotations 中，我们假设在编译示例时使用了该标志。

</ul>
<div id="2.2: C++的历史-2.2.3: 编译C++程序-2.2.3.1: 在 MS-Windows 下C++"><h3 id="2.2.3.1: 在 MS-Windows 下C++" class="header"><a href="#2.2: C++的历史-2.2.3: 编译C++程序-2.2.3.1: 在 MS-Windows 下C++">2.2.3.1: 在 MS-Windows 下C++</a></h3></div>
<p>
对于 MS-Windows 系统，Cygnus ( <a href="http://sources.redhat.com/cygwin">http://sources.redhat.com/cygwin</a> ) 提供了安装 GNU g++ 编译器的基础。
</p>

<p>
在访问上述 URL 以获取免费的 g++ 编译器时，单击“现在安装”。这将下载文件 setup.exe，可以运行该文件以安装 Cygwin。可以通过 setup.exe 从互联网下载要安装的软件。Cygwin 页面上描述了其他的下载方法（例如使用 CD-ROM）。安装过程是交互式的。除非有理由更改，否则应接受所提供的默认值。
</p>

<p>
最新的 GNU g++ 编译器可以从 <a href="http://gcc.gnu.org">http://gcc.gnu.org</a> 上获取。如果 Cygnus 发行版中提供的编译器落后于最新版本，则可以下载最新版本的源代码，然后使用已有的编译器构建编译器。编译器的网页（如上所述）包含了详细的操作说明。在 Cygnus 环境中构建新编译器的经验表明，该过程非常顺利。
</p>

<div id="2.2: C++的历史-2.2.3: 编译C++程序-2.2.3.2: 编译C++源文本"><h3 id="2.2.3.2: 编译C++源文本" class="header"><a href="#2.2: C++的历史-2.2.3: 编译C++程序-2.2.3.2: 编译C++源文本">2.2.3.2: 编译C++源文本</a></h3></div>

<p>
一般情况下，可以使用以下命令编译 C++ 源文件 <code>source.cc</code>：
</p>
<pre><code>g++ source.cc
</code></pre>

<p>
这会生成一个二进制程序（a.out 或 a.exe）。如果默认名称不合适，则可以使用 -o 标志指定可执行文件名（这里生成程序 source）：
</p>
<pre><code>g++ -o source source.cc
</code></pre>

<p>
如果只需要编译而不需要链接，可以使用 -c 标志生成已编译的模块：
</p>
<pre><code>g++ -c source.cc
</code></pre>

<p>
这会生成文件 source.o，稍后可以将其链接到其他模块。正如所指出的那样，要提供编译器选项 <code>-std=c++14</code> 来激活 C++14 标准的特性。
</p>

<p>
C++ 程序很快变得过于复杂，难以手动维护。对于所有的严肃编程项目，都要使用程序维护工具。通常使用标准的 make 程序来维护 C++ 程序，但也存在良好的替代品，如<a href="https://fbb-git.github.io/icmake/">icmake</a> 或 <a href="https://github.com/bneijt/ccbuild/">ccbuild</a> 程序维护工具。
</p>

<p>
强烈建议在学习 C++ 的早期开始使用维护工具。
</p>

<div id="2.3: C++：优势和主张"><h1 id="2.3: C++：优势和主张" class="header"><a href="#2.3: C++：优势和主张">2.3: C++：优势和主张</a></h1></div>

<p>
通常有人说在 C++ 中编程会导致程序更好。C++ 的一些优点包括：
</p>
<ul>
<li>
由于旧代码可以重用，新程序可以在更短的时间内开发出来。

<li>
创建和使用新的数据类型比在 C 中更容易。

<li>
在 C++ 下的内存管理会更加容易和透明。

<li>
程序会更少出错，因为 C++ 使用更严格的语法和类型检查。

<li>
在 C++ 中实现“数据隐藏”（一个程序部分使用数据，而其他程序部分无法访问数据）会更容易。

</ul>
<p>
这些断言中哪些是真实的？最初，我们的印象是 C++ 语言有些被高估了，这对整个面向对象编程（OOP）方法也是如此。
对 C++ 语言的热情类似于曾经关于 Lisp 和 Prolog 等人工智能（AI）语言所说的指控：这些语言被认为可以“几乎不费力地”解决最困难的 AI 问题。新语言经常被过度宣传：最终，每个问题都可以在任何编程语言（如 BASIC 或汇编语言）中编码。 
</p>

<p>
给定编程语言的优缺点不在于“你可以用它们做什么”，而在于“语言提供哪些工具来实现高效且易于理解的解决方案以解决编程问题”。这些工具通常采用语法限制的形式，通过应用或“embracing拥抱”这种语法形式来强制或促进某些结构，或者仅仅是通过应用这些语法形式来表达意图。现在，我们使用流控制语句、函数、对象或甚至（在 C++ 中）所谓的<code>模板</code>来组织和结构化代码，以自己选择的语言“流畅地”表达自己，而不是使用一长串简单的汇编指令。
</p>

<p>
关于对 C++ 的上述指控，我们支持以下观点。
</p>
<ul>
<li>
在 C 中可以通过使用函数库实现在重用现有代码的同时开发新程序。函数可以收集在库中，无需在每个新程序中重新发明。但是，C++ 除了函数库之外还提供了特定的语法可能性来实现代码重用（请参阅 <a href="第13章 继承.html">第13章</a> 和 <a href="第21章 函数和变量模板.html">第21章</a> ）。

<li>
在 C 中创建和使用新数据类型是可能的，例如，通过使用结构体、类型定义等。从这些类型中可以派生出其他类型，从而导致包含结构体的结构体等。在 C++ 中，通过定义完全“自支持”的数据类型来增强这些功能，自动处理它们的内存管理（无需使用独立运行的内存管理系统，如 Java）。

<li>
在 C++ 中，内存管理原则上可以像在 C 中一样容易或困难。特别是当使用专用的 C 函数（如 xmalloc 和 xrealloc）时，可以分配内存或在内存池用尽时中止程序。但是，使用 malloc 等函数很容易犯错误。在 C 程序中经常出现的错误可以追溯到使用 malloc 时的误差。相反，C++ 提供了一些设施，以比较安全的方式分配内存，使用它的 operator new。

<li>
关于“bug proneness”，我们可以说，C++ 的确比 C 使用更严格的类型检查。然而，大多数现代的 C 编译器都实现了“警告级别”；然后程序员可以选择忽略或摆脱这些警告。在 C++ 中，许多这样的警告会变成致命错误（编译停止）。

<li>
至于“数据隐藏”，C 确实提供了一些工具。例如，尽可能使用局部或静态变量，并且可以通过专用函数来操作特殊的数据类型，例如结构体。使用这些技术，在 C 语言中其实也可以实现数据隐藏；尽管必须承认，C++ 提供了特殊的语法结构，使得在 C++ 中比在 C 中更容易实现“数据隐藏”（以及更一般地说，“封装”）。

</ul>
<p>
C++ 特别是面向对象编程并不是所有编程问题的解决方案。然而，该语言确实提供了各种新的和优雅的设施值得研究。缺点是，与 C 相比，C++ 的语法复杂度显著增加。这可能被视为该语言的一个严重缺陷。虽然我们随着时间的推移已经习惯了这种增加的复杂性，但过渡既不快速也不轻松。
</p>

<p>
通过《C++ 注释》，我们希望通过关注 C++ 相对于 C 的增加并省略纯 C，帮助读者从 C 过渡到 C++。我们希望您喜欢这个文档并从中受益。
</p>

<p>
祝您在进入 C++ 的旅程中享受并好运！
</p>

<div id="2.4: 什么是面向对象编程？"><h1 id="2.4: 什么是面向对象编程？" class="header"><a href="#2.4: 什么是面向对象编程？">2.4: 什么是面向对象编程？</a></h1></div>

<p>
对象导向编程与C语言的过程式编程
在C语言中，问题通常被分解成子问题，直到可以编写子任务为止，从而解决问题。因此，通过参数和变量（全局、局部或静态）进行通讯，创建了一组函数。与之相反（或者更好的说法是：此外），面向对象的方法通过识别问题陈述中使用的关键字来解决问题。然后，在图表中描述这些关键字，其中箭头在这些关键字之间绘制以描绘内部层次结构。这些关键字变成了实现中的对象，而层次结构定义了这些对象之间的关系。这里使用术语“对象”来描述一个有限、定义明确的结构，包含有关实体的所有信息：数据类型和操作数据的函数。下面是一个面向对象方法的示例：
</p>

<p>
	一个汽车经销商和汽车修理厂公司的员工和所有者的薪酬如下。首先，在修理厂工作的机械师每月会获得一定的工资。其次，公司的所有者每月会获得一定的固定<code>月薪</code>。第三，有在展厅工作的汽车销售员，他们每月会获得<code>月薪</code>，以及每售出一辆车就会获得一笔<code>奖金</code>。最后，公司雇用了四处旅行的二手车买家，这些员工每月都会获得<code>月薪</code>、每买一辆车就会获得一笔<code>奖金</code>，以及<code>旅行费用的补偿</code>。
</p>

<p>
当表示上述薪酬管理时，关键字可以是机械师、所有者、销售员和买家。这些单位的属性是：<code>月薪</code>，有时还有每次购买或销售的<code>奖金</code>，有时还有<code>旅行费用的赔偿</code>。通过这种方式分析问题，我们得到以下表示：
</p>

<ul>
<li>
所有者和机械师可以用相同的类型表示，每月获得固定薪水。这种类型的相关信息将是<code>月薪</code>。此外，此对象可以包含姓名、地址和社会安全号码等数据。

<li>
在展厅工作的汽车销售员可以表示为与上述相同类型，但具有一些额外的功能：交易（销售）数量和 每笔交易的<code>奖金</code>。

<li>
在对象层次结构中，我们将让销售员从所有者和机械师中 <span id="2.4: 什么是面向对象编程？-“派生”"></span><strong id="“派生”">“派生”</strong> 出来，以定义前两个对象之间的依赖关系。

<li>
最后，还有二手车买家。他们与销售员共享功能，除了<code>旅行费用</code>。因此，附加功能将包括所产生的费用，而此类型将 <span id="2.4: 什么是面向对象编程？-从销售员派生出来"></span><strong id="从销售员派生出来">从销售员派生出来</strong> 。

</ul>
<p>
示例层次图片：<img src="https://fbb-git.github.io/cppannotations/cppannotations/html/intro/objects.gif" alt="imageName" style="width:12em;height:12em;display: block; margin: 0 auto;" />
</p>

<p>
上述层次结构的定义过程始于对最简单类型的描述。传统上（在一些流行的面向对象语言仍然如此），从基本集合中派生出更复杂的类型，每个派生都会增加一些额外的功能。从这些派生类型中，可以无限派生更复杂的类型，直到可以表示整个问题。然而，多年来，这种方法在C++中已经不那么流行了，因为它通常会导致过度紧密的耦合，从而降低了复杂程序的理解性、可维护性和可测试性。在C++中，面向对象程序越来越倾向于小型、易于理解的层次结构，限制耦合，以及设计模式（参见Gamma等人（1995））在开发过程中发挥核心作用。
</p>

<p>
尽管如此，在C++中，类经常用于定义对象的特征。类包含执行有用操作所必需的功能。通常情况下，类不会将所有功能（通常也不包括数据）提供给其他类的对象。正如我们将看到的那样，类倾向于以这样的方式隐藏其属性，以使它们不会被外部世界直接修改。相反，专门的函数用于访问或修改对象的属性。因此，类类型对象能够维护自身的完整性。这里的核心概念是封装，而数据隐藏仅是其一个例子。这些概念在第7章中进一步解释。
</p>

<div id="2.5: C 和 C++ 之间的差异"><h1 id="2.5: C 和 C++ 之间的差异" class="header"><a href="#2.5: C 和 C++ 之间的差异">2.5: C 和 C++ 之间的差异</a></h1></div>

<p>
本节介绍了一些C++代码示例，并突出了C和C++之间的一些区别。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.1: 函数main"><h2 id="2.5.1: 函数main" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.1: 函数main">2.5.1: 函数main</a></h2></div>

<p>
在C++中，函数main只有两种变体：int main()和int main(int argc，char ** argv)。
注意事项：
</p>
<ul>
<li>
main函数的返回类型为int，而不是void;

<li>
函数main不能被重载（除了上述签名之外）;

<li>
在main函数结尾处不需要使用显式的return语句。如果省略，main将返回0;

<li>
argv[argc] 的值等于0;

<li>
C ++标准未定义“第三个char ** envp参数”，因此应避免使用。相反，应声明 extern char ** environ全局变量，以提供访问程序环境变量的方式。其最后一个元素的值为0;

<li>
C++程序在main函数返回时正常结束。对于main函数使用函数try块（参见 <a href="第10.11节.html">第10.11节</a> ）也被视为C++程序的正常结束。当C++正常结束时，全局对象的析构函数（参见<a href="">第9.2节</a>）将被激活。像exit（3）这样的函数通常不会结束C++程序，因此使用此类函数已被弃用。

</ul>
<div id="2.5: C 和 C++ 之间的差异-2.5.2: 行尾注释"><h2 id="2.5.2: 行尾注释" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.2: 行尾注释">2.5.2: 行尾注释</a></h2></div>

<p>
根据ANSI/ISO定义，C++语法中实现了“行尾注释”。此注释以//开始，以行尾标记结束。标准C注释，由<code>/*</code>和<code>*/</code>界定，仍然可以在C++中使用：
</p>
<pre>
    int main()
    {
        // 这是行尾注释
        // 每行只能有一个注释
        /*
            这是标准C注释，可跨多行
        */
    }
</pre>

<p>
尽管在示例中使用了C类型的注释，但建议不要在C++函数体内使用此类注释。有时需要暂时禁用现有代码，例如用于测试。在这些情况下，使用标准C注释非常实用。如果被禁用的代码本身包含这种注释，则会导致嵌套注释行，从而导致编译器错误。因此，经验法则是不要在C++函数体内使用C类型注释（或者，当然也可以使用<code>#if 0</code> 到<code>#endif</code>对预处理器指令对）。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.3: 严格的类型检查"><h2 id="2.5.3: 严格的类型检查" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.3: 严格的类型检查">2.5.3: 严格的类型检查</a></h2></div>

<p>
C++使用非常严格的类型检查。在调用函数之前必须知道每个函数的原型，并且调用必须与原型匹配。下面的程序：
</p>

<pre>
    int main()
    {
        printf("Hello World\n");
    }
</pre>

<p>
在C下通常可以编译通过，尽管有一个警告，即printf()是一个未知的函数。但是在C++编译器中，这种情况下应该会失败（注意，应该是，因为不同的编译器可能会有不同的行为）。这个错误当然是由于缺少#include &lt;stdio.h&gt;（在C++中更常见的是#include &lt;cstdio&gt;指令）。
</p>

<p>
另外，在C++中，正如我们在前面看到的，main函数总是使用int返回值。虽然可以定义int main()而不显式定义返回语句，但在main函数中不可能使用没有显式int表达式的return语句。例如：
</p>
<pre>
    int main()
    {
        return;     // 无法编译：需要int表达式，例如
                    // return 1;
    }
</pre>

<div id="2.5: C 和 C++ 之间的差异-2.5.4: 函数重载"><h2 id="2.5.4: 函数重载" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.4: 函数重载">2.5.4: 函数重载</a></h2></div>
<p>
在C++中，可以定义具有相同名称但执行不同操作的函数。这些函数必须在它们的参数列表（和/或它们的const属性）中有所不同。下面给出了一个例子：
</p>

<pre>
    #include &lt;stdio.h&gt;
    void show(int val)
    {
        printf("Integer: %d\n", val);
    }
    void show(double val)
    {
        printf("Double: %lf\n", val);
    }
    void show(char const *val)
    {
        printf("String: %s\n", val);
    }
    int main()
    {
        show(12);
        show(3.1415);
        show("Hello World!\n");
    }
</pre>

<p>
在上面的程序中，定义了三个名为show的函数，它们的参数列表分别为<code>int</code>、<code>double</code>和<code>char *</code>。这些函数具有相同的名称。具有相同名称但参数列表不同的函数称为“重载函数”。定义这种函数的行为称为“函数重载”。
</p>

<p>
C++编译器以一种相当简单的方式实现函数重载。尽管这些函数共享它们的名称（在此示例中为show），但编译器（因此链接器）使用完全不同的名称。将源文件中的名称转换为内部使用的名称的过程称为“名称重整name mangling”。例如，C++编译器可能将原型<code>void show(int)</code>转换为内部名称VshowI，而具有<code>char *</code>参数的类似函数可能被称为VshowCP。实际上<code>内部使用的名称取决于编译器，对于程序员来说并不重要</code>，除非这些名称在库的内容列表中显示。
</p>

<p>
关于函数重载的一些其他说明：
</p>

<ul>
<li>
不要将用于执行概念上不同任务的函数进行函数重载。在上面的例子中，show函数仍然有些相关（它们将信息打印到屏幕上）。

<li>
然而，也很可能定义两个名为lookup的函数，其中一个会在列表中查找名称，另一个会确定视频模式。在这种情况下，这两个函数的行为没有共同点。因此，更实际的做法是使用暗示它们动作的名称，例如findname和videoMode。

<li>
C++不允许具有完全相同名称但仅返回值不同的函数，因为程序员始终可以选择使用或忽略函数的返回值。例如，代码片段printf("Hello World!\n");提供了关于函数printf的返回值的信息。两个仅在返回类型上有所不同的printf函数因此无法被编译器区分。

<li>
<a href="第7章 类.html">第7章</a> 介绍了“const成员函数”的概念（参见<a href="第7章 类.html">第7.7节</a>）。这里仅提到，类通常与它们相关的成员函数相关联（例如， <a href="第5章 数据类型string.html">第5章</a> 对该概念进行了非正式介绍）。除了使用 <span id="2.5: C 和 C++ 之间的差异-2.5.4: 函数重载-不同的参数列表"></span><strong id="不同的参数列表">不同的参数列表</strong> 重载成员函数外，还可以通过它们的 <span id="2.5: C 和 C++ 之间的差异-2.5.4: 函数重载-const属性"></span><strong id="const属性">const属性</strong> 重载成员函数。在这些情况下，类可能有一对具有相同名称和相同参数列表的成员函数。然后，这些函数通过它们的const属性进行重载(member function的const属性)。在这种情况下，只有一个函数是 必须 具有const属性。

</ul>
<div id="2.5: C 和 C++ 之间的差异-2.5.5: 默认函数参数"><h2 id="2.5.5: 默认函数参数" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.5: 默认函数参数">2.5.5: 默认函数参数</a></h2></div>

<p>
在C++中，定义函数时可以提供“默认参数”。当程序员没有指定这些参数时，编译器会提供它们。例如：
</p>

<pre>
	#include &lt;stdio.h&gt;
	void showstring(char *str = "Hello World!\n");
	int main()
	{
	    showstring("Here's an explicit argument.\n");
	    showstring();           // 实际上等价于：
	                            // showstring("Hello World!\n");
	}
</pre>

<p>
在定义了默认参数的情况下，省略参数的可能性只是一个不错的功能：除非在调用时明确指定了它，否则是编译器提供缺失的参数。使用默认参数时，程序代码既不会更短也不会更高效。
</p>

<p>
函数可以定义多个默认参数：
</p>

<pre>
	void two_ints(int a = 1, int b = 4);
	int main()
	{
	    two_ints();            // 参数：1, 4
	    two_ints(20);          // 参数：20, 4
	    two_ints(20, 5);       // 参数：20, 5
	}
</pre>

<p>
当调用函数<code>two_ints</code>时，编译器会在必要时提供一个或两个参数。然而，像<code>two_ints(,6)</code>这样的语句是不被允许的：省略参数时必须在右侧。
</p>

<p>
默认参数必须在编译时已知，因为在这个时刻参数被提供给函数。因此， <span id="2.5: C 和 C++ 之间的差异-2.5.5: 默认函数参数-默认参数必须在函数的声明中而不是在其实现中"></span><strong id="默认参数必须在函数的声明中而不是在其实现中">默认参数必须在函数的声明中而不是在其实现中</strong> 被提及：
</p>
<pre>
	// 示例头文件
	extern void two_ints(int a = 1, int b = 4);
	// 例如在two.cc中的函数代码
	void two_ints(int a, int b)
	{
	    ...
	}
</pre>

<p>
当检测到函数定义中的默认参数时，当前编译器会产生编译时错误。 <span id="2.5: C 和 C++ 之间的差异-2.5.5: 默认函数参数-在函数定义中提供默认参数是错误的"></span><strong id="在函数定义中提供默认参数是错误的">在函数定义中提供默认参数是错误的</strong> 。当其他源代码使用函数时，编译器读取头文件而不是函数定义。 因此，若是在函数定义中设置默认参数，则编译器无法确定默认函数参数的值。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.6: NULL指针 和 0指针 和 nullptr"><h2 id="2.5.6: NULL指针 和 0指针 和 nullptr" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.6: NULL指针 和 0指针 和 nullptr">2.5.6: NULL指针 和 0指针 和 nullptr</a></h2></div>

<p>
C++中的<code>NULL</code>和<code>nullptr</code>
</p>

<p>
在C++中，所有零值都被编码为0。在C语言中，NULL在指针的上下文中经常被使用。这种差异纯粹是风格上的，尽管这种风格已经被广泛采用。在C++中应该避免使用<code>NULL</code>（因为它是一个宏，而宏可以 <span id="2.5: C 和 C++ 之间的差异-2.5.6: NULL指针 和 0指针 和 nullptr-而且应该"></span><strong id="而且应该">而且应该</strong> 在C++中轻松避免使用，参见 <a href="第8章 Static 数据和函数.html">8.1.4节</a> ）。而是几乎总是可以使用0。
</p>

<p>
几乎总是，但并不总是。由于C++允许函数重载（参见2.5.4节），程序员可能会在 <a href="第2章 引言.html#2.5.4: 函数重载">2.5.4节</a> 所示的情况下面临意外的函数选择：
</p>

<pre cpp>
	#include &lt;stdio.h&gt;
	void show(int val)
	{
		printf("Integer: %d\n", val);
	}
	void show(double val)
	{
		printf("Double: %lf\n", val);
	}
	void show(char const *val)
	{
		printf("String: %s\n", val);
	}

	int main()
	{
		show(12);
		show(3.1415);
		show("Hello World!\n");
	}
</pre>

<p>
在这种情况下，打算调用<code>show(char const *)</code>的程序员可能会调用<code>show(0)</code>。但这行不通，因为0被解释为int，因此调用了<code>show(int)</code>。但调用<code>show(NULL)</code>也不起作用，因为C++通常将NULL定义为0，而不是<code>((void *)0)</code>。因此，再次调用<code>show(int)</code>。为了解决这些类型的问题，新的C++标准引入了关键字<code>nullptr</code>，代表0指针。在当前的示例中，程序员应该调用<code>show(nullptr)</code>来避免选择错误的函数。nullptr值也可以用来初始化指针变量。例如：
</p>

<pre cpp>
	int *ip = nullptr;      // OK
	int value = nullptr;    // 错误：value不是指针
</pre>

<div id="2.5: C 和 C++ 之间的差异-2.5.7: 参数列表void"><h2 id="2.5.7: 参数列表void" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.7: 参数列表void">2.5.7: 参数列表void</a></h2></div>

<p>
在C中，一个参数列表为空的函数原型，例如：
</p>

<pre c>
	void func();
</pre>

<p>
意味着声明的函数的参数列表没有原型：对于使用此原型的函数，使用一组参数调用<code>func</code>, C语言编译器不会警告。在C中，当明确声明不需要参数时，使用关键字<code>void</code>，例如：
</p>

<pre c>
	void func(void);
</pre>

<p>
由于C++执行严格的类型检查，因此在C++中，空参数列表表示参数的完全缺失。因此省略了关键字<code>void</code>。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.8: define __cplusplus"><h2 id="2.5.8: define __cplusplus" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.8: define __cplusplus">2.5.8: define __cplusplus</a></h2></div>
<p>
符合ANSI/ISO标准的每个C++编译器都定义了符号<code>__cplusplus</code>，就好像每个源文件都以预处理器指令<code>#define __cplusplus</code>为前缀一样。
我们将在以下章节中看到使用此符号的示例。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.9: 使用标准 C 函数"><h2 id="2.5.9: 使用标准 C 函数" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.9: 使用标准 C 函数">2.5.9: 使用标准 C 函数</a></h2></div>
<ul>
<li>
C函数在C++中的使用

</ul>
<p>
普通的C函数，例如编译并收集在运行时库中的函数，也可以在C++程序中使用。但是，这种函数必须声明为C函数。
</p>

<p>
例如，以下代码片段将函数<code>xmalloc</code>声明为C函数：
</p>

<pre cpp>
	extern "C" void *xmalloc(int size);
</pre>

<p>
此声明类似于C中的声明，只是原型前缀为<code>extern "C"</code>。
</p>

<p>
另一种声明C函数的稍微不同的方法是：
</p>

<pre cpp>
	extern "C"
	{
		// C声明放在这里
	}
</pre>

<p>
也可以在声明的位置放置预处理器指令。例如，声明C函数的C头文件<code>myheader.h</code>可以在C++源文件中包含如下：
</p>

<pre cpp>
	extern "C"
	{
		#include &lt;myheader.h&gt;
	}
</pre>

<p>
尽管可以使用这两种方法，但在C++源中实际上很少遇到。下一节介绍的是声明外部C函数的更常用的方法。
</p>
<div id="2.5: C 和 C++ 之间的差异-2.5.10: C 和 C++ 的头文件"><h2 id="2.5.10: C 和 C++ 的头文件" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.10: C 和 C++ 的头文件">2.5.10: C 和 C++ 的头文件</a></h2></div>

<p>
C++中预定义的符号<code>__cplusplus</code>和定义<code>extern "C"</code>函数的可能性，提供了创建 <span id="2.5: C 和 C++ 之间的差异-2.5.10: C 和 C++ 的头文件-同时适用于C和C++的头文件"></span><strong id="同时适用于C和C++的头文件">同时适用于C和C++的头文件</strong> 的能力。这样的头文件可以声明一组 <span id="2.5: C 和 C++ 之间的差异-2.5.10: C 和 C++ 的头文件-在C和C++程序中都能使用的函数"></span><strong id="在C和C++程序中都能使用的函数">在C和C++程序中都能使用的函数</strong> 。
</p>

<p>
这样的头文件的设置如下：
</p>

<pre cpp>
#ifdef __cplusplus
	extern "C"
	{
#endif
		/* 声明C数据和函数插入在这里，例如 */
		void *xmalloc(int size);
#ifdef __cplusplus
	}
#endif
</pre>

<p>
使用这个设置，一个正常的C头文件被<code>extern "C" {</code>包围，它出现在文件的顶部附近，并由<code>}，</code>出现在文件的底部附近。<code>#ifdef</code>指令测试编译的类型：C或C++。例如，像<code>stdio.h</code>这样的C标准头文件就是这样建立的，因此可以用于C和C++。
</p>

<p>
此外，C++头文件应该支持包含保护。在C++中，同一源文件中两次包含相同的头文件通常是不可取的。这种多重包含可以通过在头文件中包含<code>#ifndef</code>指令来轻松避免。例如：
</p>

<pre cpp>
#ifndef MYHEADER_H_
#define MYHEADER_H_
    // 插入头文件的声明，使用 #ifdef __cplusplus 等指令
#endif
</pre>

<p>
当预处理器首次扫描此文件时，符号<code>MYHEADER_H_</code>尚未定义。<code>#ifndef</code>条件成功，并扫描所有声明。另外，符号<code>MYHEADER_H_</code>被定义。
</p>

<p>
当编译同一源文件时再次扫描此文件时，符号<code>MYHEADER_H_</code>已被定义，因此编译器跳过<code>#ifndef</code>和<code>#endif</code>指令之间的所有信息。
</p>

<p>
在这种情况下，符号名称<code>MYHEADER_H_</code>仅用于识别目的。例如，头文件的名称可以用于此目的，以大写字母表示，并用下划线字符代替句点。
</p>

<p>
除此之外，惯例是给C头文件一个扩展名<code>.h</code>，而不给C++头文件任何扩展名。例如，标准的iostreams<code>cin</code>、<code>cout</code>和<code>cerr</code>在包含头文件<code>iostream</code>之后可用，而不是<code>iostream.h</code>。在注释中，这个约定是用于标准的C++头文件，但不一定是在其他地方。
</p>

<p>
关于头文件还有更多需要说的。第 <a href="第7章 类.html">7.11节</a> 提供了对C++头文件的首选组织方式的深入讨论。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.11: 定义局部变量"><h2 id="2.5.11: 定义局部变量" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.11: 定义局部变量">2.5.11: 定义局部变量</a></h2></div>

<p>
尽管在 C 语言中，局部变量可以在任意位置被定义，但是最好在需要使用它们时再进行定义。虽然这需要一些适应时间，但最终会产生更易读、易于维护且通常更高效的代码，而不是在复合语句的开头定义变量。在定义局部变量时，建议遵循以下几点：
</p>

<ol>
<li>
局部变量应该在“直觉上正确”的位置被创建，例如在下面的示例中。这不仅包括 for 语句，也包括所有只在函数的中途需要变量的情况。

<li>
变量的 <span id="2.5: C 和 C++ 之间的差异-2.5.11: 定义局部变量-作用域应尽可能地被限制和局限"></span><strong id="作用域应尽可能地被限制和局限">作用域应尽可能地被限制和局限</strong> 。当可避免时，局部变量 <span id="2.5: C 和 C++ 之间的差异-2.5.11: 定义局部变量-不应该在函数的开头定义，而应该在其第一次使用的地方定义"></span><strong id="不应该在函数的开头定义，而应该在其第一次使用的地方定义">不应该在函数的开头定义，而应该在其第一次使用的地方定义</strong> 。

<li>
应该避免使用全局变量，因为很容易丢失哪个全局变量用于什么目的。 <span id="2.5: C 和 C++ 之间的差异-2.5.11: 定义局部变量-在C++中，很少需要使用全局变量"></span><strong id="在C++中，很少需要使用全局变量">在C++中，很少需要使用全局变量</strong> ，通过局部化变量，可以轻松地防止使用同一变量用于多个目的而使每个变量的个体目的无效的情况。

<li>
如果合适的话， <span id="2.5: C 和 C++ 之间的差异-2.5.11: 定义局部变量-可以使用嵌套块来将辅助变量局部化"></span><strong id="可以使用嵌套块来将辅助变量局部化">可以使用嵌套块来将辅助变量局部化</strong> 。然而，存在局部变量应该出现在嵌套语句中的情况。 for 语句当然是一个例子，但是局部变量也可以在 if-else语句的条件子句 , switch语句的选择子句 和 while语句的条件子句 中定义。因此，这些定义的变量可用于整个语句，包括其嵌套语句。

</ol>
<p>
例如，考虑以下 switch 语句：
</p>

<pre cpp>
	#include &lt;stdio.h&gt;
	int main()
	{
		switch (int c = getchar())
		{
			case 'a':
			case 'e':
			case 'i':
			case 'o':
			case 'u':
				printf("Saw vowel %c\n", c);
			break;
			case EOF:
				printf("Saw EOF\n");
			break;
			case '0' ... '9':
				printf("Saw number character %c\n", c);
			break;
			default:
				printf("Saw other character, hex value 0x%2x\n", c);
		}
	}
</pre>

<p>
注意字符 <code>c</code> 的定义位置：它在 switch 语句的表达式部分中定义。这意味着 <code>c</code> 仅在 switch 语句本身及其嵌套子语句中可用，但不在 switch 的作用域之外可用。
</p>

<p>
相同的方法可以用于 if 和 while 语句：在 if 和 while 语句的条件部分定义的变量可以在它们的嵌套语句中使用。但是，需要注意以下几点：
</p>

<ol>
<li>
变量定义必须导致一个初始化为数字或逻辑值的变量。

<li>
变量定义不能嵌套在更复杂的表达式中（例如使用括号）。

</ol>
<p>
后一个注意点应该不会太惊讶：为了能够评估 if 或 while 语句的逻辑条件，变量的值必须被解释为零（假）或非零（真）。通常这不是问题，但在 C++ 中，对象（例如 std::string 类型（参见<a href="第5章 数据类型string.html">第5章</a>）的对象）经常由函数返回。这些对象可能无法被解释为数字值。如果不行（例如 std::string 对象），则不能在条件或重复语句的表达式子句中定义这样的变量。因此，以下示例将不能编译：
</p>

<pre cpp>
	if (std::string myString = getString())     // 假设 getString() 返回一个 std::string 值
	{                                           // 处理 myString
	}
</pre>

<p>
上述示例需要进一步澄清。通常情况下，变量可以受益于给定局部作用域，但是在初始化之后需要立即进行额外的检查。初始化和测试不能组合在一个表达式中。需要使用两个嵌套语句。因此，以下示例也无法编译：
</p>

<pre cpp>
	if ((int c = getchar()) &amp;&amp; strchr("aeiou", c))
		printf("Saw a vowel\n");
</pre>

<p>
如果出现这种情况，可以使用两个嵌套的 if 语句或使用嵌套复合语句来局部定义 int c ：
</p>
<pre cpp>
	if (int c = getchar())             // 嵌套的 if 语句
		if (strchr("aeiou", c))
			printf("Saw a vowel\n");
</pre>
<pre cpp>
	{                                  // 嵌套的复合语句
		int c = getchar();
		if (c &amp;&amp; strchr("aeiou", c))
			printf("Saw a vowel\n");
	}
</pre>

<p>
建议在定义局部变量时遵循上述规则和建议，以提高代码的可读性、可维护性和效率。
</p>
<div id="2.5: C 和 C++ 之间的差异-2.5.12: 关键字typedef"><h2 id="2.5.12: 关键字typedef" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.12: 关键字typedef">2.5.12: 关键字typedef</a></h2></div>
<p>
在 C++ 中，关键字 typedef 仍然被使用，但在定义 union、struct 或 enum 时不再是必需的。下面的示例说明了这一点：
</p>

<p>
定义结构体：
</p>
<pre>
	struct SomeStruct
	{
	    int     a;
	    double  d;
	    char    string[80];
	};
</pre>
<p>
当定义结构体、联合或其他复合类型时，该类型的标签可以作为类型名称。在上面的示例中，类型名称是 SomeStruct。因此，可以使用类型名称来定义该类型的变量，例如：
</p>
<pre>
	SomeStruct what;
	what.d = 3.1415;
</pre>
<p>
这里定义了一个 SomeStruct 类型的变量 what，并将其成员变量 d 的值设置为 3.1415。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.13: 作为结构体的一部分的函数"><h2 id="2.5.13: 作为结构体的一部分的函数" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.13: 作为结构体的一部分的函数">2.5.13: 作为结构体的一部分的函数</a></h2></div>
<p>
在 C++ 中，我们可以将函数定义为结构体的成员。这里我们遇到了第一个具体的对象的例子：正如先前所述（见 <a href="第2章 引言.html#2.4: 什么是面向对象编程？">第2.4节</a> ），一个对象是一个包含数据的结构体，而专门的函数存在于该对象中以操作这些数据。
</p>

<p>
以下代码片段提供了一个 struct Point 的定义。在这个结构体中，声明了两个 int 数据字段和一个 draw 函数。
</p>

<pre>
	struct Point            // 定义屏幕点
	{
	    int x;              // 坐标
	    int y;              // x/y
	    void draw();        // 绘制函数
	};
</pre>

<p>
类似的结构体可以是绘画程序的一部分，并且可以用来表示像素。关于这个结构体，应该注意以下几点：
</p>

<ul>
<li>
结构体定义中提到的 <span id="2.5: C 和 C++ 之间的差异-2.5.13: 作为结构体的一部分的函数-draw函数只是一个声明"></span><strong id="draw函数只是一个声明">draw函数只是一个声明</strong> 。实际的 <span id="2.5: C 和 C++ 之间的差异-2.5.13: 作为结构体的一部分的函数-函数代码定义操作函数的行为在其他地方"></span><strong id="函数代码定义操作函数的行为在其他地方">函数代码定义操作函数的行为在其他地方</strong> 找到（有关结构体内函数的概念在 <a href="第3章 C++的第一印象.html">第3.2节</a> 中进一步讨论）。

<li>
Point 结构体的大小等于其两个int的大小。在 <span id="2.5: C 和 C++ 之间的差异-2.5.13: 作为结构体的一部分的函数-结构体内声明的函数不会影响其大小"></span><strong id="结构体内声明的函数不会影响其大小">结构体内声明的函数不会影响其大小</strong> 。编译器通过只在 Point 的上下文中允许 draw 函数来实现这种行为。

<li>
Point 结构体可以这样使用：
<pre>
	Point a;                // 屏幕上的两个点
	Point b;
	a.x = 0;                // 定义第一个点
	a.y = 10;
	a.draw();               // 绘制它
	b = a;                  // 将 a 复制到 b
	b.y = 20;               // 重新定义 y 坐标
	b.draw();               // 绘制它
</pre>

</ul>
<p>
如上例所示，结构体的一部分的函数可以使用点<code>.</code>选择（当对象是指针时使用箭头<code>-&gt;</code>运算符）。这与选择结构体的数据字段的方式是相同的。
</p>

<p>
这种语法结构的背后思想是，几种类型可能包含具有相同名称的函数(属于各自的结构体,故函数入口地址不一样)。例如，表示圆的结构体可能包含三个 int 值：两个值用于圆心的坐标，一个值用于半径。类似于 Point 结构体，Circle 现在可以有一个 draw 函数来画圆。
</p>

<div id="2.5: C 和 C++ 之间的差异-2.5.14: 操作数的求值顺序"><h2 id="2.5.14: 操作数的求值顺序" class="header"><a href="#2.5: C 和 C++ 之间的差异-2.5.14: 操作数的求值顺序">2.5.14: 操作数的求值顺序</a></h2></div>

<p>
<span id="2.5: C 和 C++ 之间的差异-2.5.14: 操作数的求值顺序-子小节：操作数的求值顺序"></span><strong id="子小节：操作数的求值顺序">子小节：操作数的求值顺序</strong>
</p>

<p>
传统上，除了布尔运算符 <code>and</code> 和 <code>or</code> 之外，二元运算符的操作数表达式的求值顺序没有定义。C++ 改变了这一点，对于后缀表达式、赋值表达式（包括复合赋值）和移位运算符：
</p>
<ul>
<li>
后缀表达式（如索引运算符<code>[]</code>和成员选择器<code>.</code>,<code>-&gt;</code>）从左到右求值；

<li>
赋值表达式(<code>+=</code>,<code>-=</code>,<code>=</code>,...)从右到左求值；

<li>
移位运算符(<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,...)的操作数从左到右求值。

</ul>
<p>
在以下示例中，无论它们是单个变量、括号表达式还是函数调用，都是先求值 first，然后是 second，然后是 third，然后是 fourth：
</p>

<pre cpp>
	first.second
	fourth += third = second += first
	first &lt;&lt; second &lt;&lt; third &lt;&lt; fourth
	first &gt;&gt; second &gt;&gt; third &gt;&gt; fourth
</pre>

<p>
此外，在重载运算符时，实现重载运算符的函数的求值方式类似于重载的内置运算符，而不是一般的函数调用的顺序。
<hr />
<span id="2.5: C 和 C++ 之间的差异-2.5.14: 操作数的求值顺序-子小节：属性Attributes"></span><strong id="子小节：属性Attributes">子小节：属性Attributes</strong>
</p>
<blockquote>
<p>
 在 C++ 中，属性通常是用于向编译器提供额外的信息，以帮助编译器优化代码或生成更有用的警告。

</p></blockquote>
</pre></code>
<p>
属性用于通知编译器,有意义但是会导致编译器发出警告的情况。目前已定义以下属性：
</p>

<ul>
<li>
<code>[[fallthrough]]</code>  --- 即使未break，也让编译器闭嘴的一个属性(目前仅用于 switch 语句中的 case 分支)

</ul>
<blockquote>
<p>
 如果当前case分支中不加break, 便会执行下一个case分支的代码。为了实现一些特定的逻辑，所以有意不加break, 但是又不想听到编译器的抱怨，该怎么样让编译器"闭嘴"呢？此时C++17中引入的fallthrough便派上用场了
 
</p></blockquote>
</pre></code>
<p>
当 switch 语句中的 case 条目下嵌套的语句进入后续的 case 或 default 条目时，编译器会发出“falling through”警告。如果 fall through 是有意的，则应使用属性 <a href="fallthrough.html">fallthrough</a>。以下是一个带注释的示例：
</p>

<pre cpp>
void function(int selector)
{
    switch (selector)
    {
        case 1:
        case 2:             // 没有 fall through，但是合并了 entry points
            cout &lt;&lt; "cases 1 and 2\n";
        [[fallthrough]]     // 尽管没写break，编译器也没有警告：有意的 fall through
        case 3:
            cout &lt;&lt; "case 3\n";
        case 4:             // 编译器提示 警告：没有宣布 fall through。
            cout &lt;&lt; "case 4\n";
        [[fallthrough]]     // 编译器提示 错误：没有东西可以 fall through
    }
}
</pre>

<ul>
<li>
<code>[[maybe_unused]]</code> --- 即使未使用变量，也让编译器闭嘴

</ul>
<p>
此属性可应用于类、typedef 名称、变量、参数、非静态数据成员、函数、枚举或枚举器。当它应用到实体时，当实体未使用时不会生成警告。示例：
</p>

<pre cpp>
void fun([[maybe_unused]] size_t argument)
{
    // argument 未被使用，但不会发出警告告诉你
}
</pre>

<ul>
<li>
<code>[[nodiscard]]</code> --- 假如未使用返回值(忘了使用,不应当抛弃)，让编译器告警

</ul>
<blockquote>
<p>
 例如，当一个函数返回一个指针或引用时，如果该指针或引用未被使用，可能会导致内存泄漏或资源泄漏。在这种情况下，程序员希望能够得到编译器的警告，以避免这些错误。

</p></blockquote>
</pre></code>
<p>
属性 <a href="nodiscard.html">nodiscard</a> 可在声明函数、类或枚举时指定。如果将函数声明为 <a href="nodiscard.html">nodiscard</a> 或者函数返回之前已用 <a href="nodiscard.html">nodiscard</a> 声明的实体，则仅当将该函数的返回值显式转换为 void 时，才允许忽略该函数的返回值。否则，当未使用返回值时，将发出警告。示例：
</p>

<pre cpp>
	int [[nodiscard]] importantInt();
	struct [[nodiscard]] ImportantStruct { ... };
	ImportantStruct factory();
	    
	int main()
	{
	    importantInt();         // 返回值未使用, 发出警告
	    factory();              // 返回值未使用, 发出警告
	}
</pre>
<hr />

<p>
Table of Contents | <a href="index.html">目录主页</a>
</p>

<p>
Previous Chapter | <a href="第1章 章节概述.html">上一章</a>
</p>

<p>
Next Chapter | <a href="第3章 C++的第一印象.html">下一章</a>
</p>

</body>
</html>
